<!-- (C) 2017 Хаджинова Н.В., каф. ИТАС, БГУИР -->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//RU">
<HTML>
<HEAD>
<LINK rel=stylesheet href="lb2/Оболочка/css/style.css" type=text/css>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=windows-1251">
<META HTTP-EQUIV="Content-Language" CONTENT="ru">
<title>Лекция № 5 &quot;Графическая библиотека OpenGL. Проекции. Тестуры. Освещение. Материалы.Трафареты. Анимация.&quot;</title>
</head>

<body>
<div align="center">
  <h1>Лекция № 5 &quot;<strong>Графическая библиотека OpenGL. Проекции. Тестуры. Освещение. Материалы.Трафареты. Анимация.</strong>&quot; </h1>
</div>
<hr>
<h2>Темы, рассматриваемые в данной лекции: </h2>
<ol>
  <li>Получение проекций. Плоскости отсечения.</li>
  <li>Управление расположением и выравниванием       объектов. Наложение текстур.</li>
  <li>Освещение. Материалы. Управление пересечением       объектов. Прозрачность объектов. Трафареты. Элементы анимации.</li>
  <li>Примеры программных реализаций.<hr>
  </li>
</ol>
<h1><a name="_Toc307897375">1.&nbsp;СВОЙСТВА  МАТЕРИАЛА И НАСТРОЙКА ОСВЕЩЕНИЯ</a></h1>
<p>&nbsp;</p>
<p>Для  создания реалистических изображений необходимо определить как свойства самого  объекта, так и свойства среды, в которой он находится. Первая группа свойств  включает в себя параметры материла, из которого сделан объект, способы  нанесения текстуры на его поверхность, степень прозрачности объекта. Ко второй  группе можно отнести количество и свойства источников света, уровень прозрачности  среды, а также модель источников света. Все эти свойства можно задавать,  используя соответствующие команды OpenGL.</p>
<h2><a name="_Toc307897376">1.1&nbsp;Свойства материала</a></h2>
<p>&nbsp;</p>
<p>Для задания параметров текущего  материала используются команды</p>
<table border="0" cellpadding="0" width="85%">
  <tr>
    <td width="99%"><p>void <strong>glMaterial[i    f](</strong>GLenum face, GLenum pname, GLtype param)<br>
      void <strong>glMaterial[i    f]v</strong>(GLenum face, GLenum pname, GLtype *params)</p></td>
  </tr>
</table>
<p>С их помощью можно определить  рассеянный, диффузный и зеркальный цвета материала, а также цвет степень  зеркального отражения и интенсивность излучения света, если объект должен  светиться. Какой именно параметр будет определяться значением <em>param</em>, зависит от значения <em>pname</em>. Список возможных значений  параметра <em>pname</em> приведен в таблице.</p>
<p>Таблица</p>
<table border="1" cellspacing="0" cellpadding="0" width="631">
  <tr>
    <td width="187"><br>
      <strong>GL_AMBIENT</strong></td>
    <td width="444"><p>параметр <em>params</em> должен содержать четыре целых    или вещественных значения цветов RGBA, которые определяют рассеянный цвет    материала (цвет материала в тени). Значение по умолчанию: (0.2, 0.2, 0.2,    1.0).</p></td>
  </tr>
  <tr>
    <td width="187"><p><strong>GL_DIFFUSE</strong></p></td>
    <td width="444"><p>параметр <em>params</em> должен содержать четыре целых    или вещественных значения цветов RGBA, которые определяют цвет диффузного    отражения материала. Значение по умолчанию: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(0.8, 0.8, 0.8, 1.0).</p></td>
  </tr>
  <tr>
    <td width="187"><p><strong>GL_SPECULAR</strong></p></td>
    <td width="444"><p>параметр <em>params</em> должен содержать четыре целых    или вещественных значения цветов RGBA, которые определяют цвет зеркального    отражения материала. Значение по умолчанию: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(0.0, 0.0, 0.0, 1.0).</p></td>
  </tr>
  <tr>
    <td width="187"><p><strong>GL_SHININESS</strong></p></td>
    <td width="444"><p>параметр <em>params</em> должен содержать одно целое или    вещественное значение в диапазоне от 0 до 128, которое определяет степень    зеркального отражения материала. Значение по умолчанию: 0.</p></td>
  </tr>
  <tr>
    <td width="187"><p><strong>GL_EMISSION</strong></p></td>
    <td width="444"><p>параметр <em>params</em> должен содержать четыре целых    или вещественных значения цветов RGBA, которые определяют интенсивность    излучаемого света материала. Значение по умолчанию: (0.0, 0.0, 0.0, 1.0).</p></td>
  </tr>
  <tr>
    <td width="187" valign="top"><p><strong>GL_AMBIENT_AND_DIFFUSE</strong></p></td>
    <td width="444" valign="top"><p>эквивалентно    двум вызовам команды <em>glMaterial*()</em> со значением pname GL_AMBIENT и GL_DIFFUSE и одинаковыми значениями <em>params</em>. </p></td>
  </tr>
</table>
<p>&nbsp;</p>
<p>Из этого следует, что вызов команды <em>glMaterial[i f]()</em> возможен только для  установки степени зеркального отражения материала. В большинстве моделей  учитывается диффузный и зеркальный отраженный свет; первый определяет  естественный цвет объекта, а второй &ndash; размер и форму бликов на его поверхности.<br>
  Параметр <em>face</em> определяет тип граней, для которых задается этот материал и  может принимать значения&nbsp;<strong>GL_FRONT</strong>,&nbsp;<strong>GL_BACK</strong>&nbsp;или&nbsp;<strong>GL_FRONT_AND_BACK</strong>.<br>
  Если в сцене материалы объектов  различаются лишь одним параметром, рекомендуется сначала установить нужный  режим, вызвав <em>glEnable()</em> c параметром&nbsp;<strong>GL_COLOR_MATERIAL</strong>, а затем  использовать команду</p>
<table border="0" cellpadding="0" width="79%">
  <tr>
    <td width="99%"><p>void <strong>glColorMaterial</strong>(GLenum    face, GLenum pname)</p></td>
  </tr>
</table>
<p>где параметр<em>&nbsp;face</em>&nbsp;имеет  аналогичный смысл, а параметр&nbsp;<em>pname</em>&nbsp;может принимать все перечисленные значения. После  этого, значения выбранного с помощью&nbsp;<em>pname</em>&nbsp;свойства материала  для конкретного объекта (или вершины) устанавливается вызовом команды <em>glColor*()</em>, что позволяет избежать  вызовов более ресурсоемкой команды <em>glMaterial*()</em> и повышает эффективность программы.</p>
<p>Пример.</p>
<table border="0" cellpadding="0" width="70%">
  <tr>
    <td width="99%"><br>
      float mat_dif[]={0.8,0.8,0.8};<br>
      float mat_amb[]= {0.2,0.2,0.2};<br>
      float mat_spec[]={0.6,0.6,0.6};<br>
      float shininess=0.7*128;<br>
      /*...*/<br>
      glMaterialfv(GL_FRONT_AND_BACK,GL_AMBIENT,mat_amb);<br>
      glMaterialfv(GL_FRONT_AND_BACK,GL_DIFFUSE,mat_dif);<br>
      glMaterialfv(GL_FRONT_AND_BACK,GL_SPECULAR,mat_spec);<br>
      glMaterialf(GL_FRONT,GL_SHININESS,shininess); </td>
  </tr>
</table>
<h2><a name="_Toc307897377">1.2&nbsp;</a>Источники света<a name="EBQAE"></a></h2>
<p>&nbsp;</p>
<p>Добавить в сцену источник света можно  с помощью команд</p>
<table border="0" cellpadding="0" width="80%">
  <tr>
    <td width="99%"><p>void <strong>glLight[i    f](</strong>GLenum light, GLenum pname, GLfloat param)<br>
      void <strong>glLight[i    f](</strong>GLenum light, GLenum pname, GLfloat *params)</p></td>
  </tr>
</table>
<p>Параметр&nbsp;<em>light</em>&nbsp;однозначно  определяет источник, и выбирается из набора специальных символических имен вида&nbsp;<strong>GL_LIGHTi</strong>&nbsp;, где i должно лежать в диапазоне от 0 до <strong>GL_MAX_LIGHT</strong>, которое  не превосходит восьми.<br>
  Оставшиеся два параметра имеют  аналогичный смысл, что и в команде <em>glMaterial*()</em>.  Рассмотрим их назначение (вначале описываются параметры для первой команды,  затем для второй):<br>
  При изменении положения источника  света следует учитывать следующие факты: если положение задается командой <em>glLight*()</em> перед определением ориентации  взгляда (командой <em>glLookAt()</em>), то  будет считаться, что источник находится в точке наблюдения. Если положение  устанавливается между заданием ориентации и преобразованиями видовой матрицы,  то оно фиксируется и не зависит от видовых преобразований. В последнем случае,  когда положение задано после ориентации и видовой матрицы, его положение можно  менять, устанавливая как новую ориентацию наблюдателя, так и меняя видовую  матрицу.<br>
  Для использования освещения сначала  надо установить соответствующий режим вызовом команды <em>glEnable(</em>GL_LIGHTNING<em>)</em>, а  затем включить нужный источник командой <em>glEnable(</em>GL_LIGHTn<em>)</em>.</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>Таблица &ndash; список возможных  параметров функции <em>glLight</em></p>
<table border="1" cellspacing="0" cellpadding="0" width="605">
  <tr>
    <td width="188"><br>
      <strong>GL_SPOT_EXPONENT</strong></td>
    <td width="417"><p>параметр <em>param</em> должен содержать целое или    вещественное число от 0 до 128, задающее распределение интенсивности света.    Этот параметр описывает уровень сфокусированности источника света. Значение    по умолчанию: 0 (рассеянный свет).</p></td>
  </tr>
  <tr>
    <td width="188"><p><strong>GL_SPOT_CUTOFF</strong></p></td>
    <td width="417"><p>параметр <em>param</em> должен содержать целое или    вещественное число между 0 и 90 или равное 180, которое определяет    максимальный угол разброса света. Значение этого параметра есть половина угла    в вершине конусовидного светового потока, создаваемого источником. Значение    по умолчанию: 180 (рассеянный свет).</p></td>
  </tr>
  <tr>
    <td width="188"><p><strong>GL_AMBIENT</strong></p></td>
    <td width="417"><p>параметр <em>params</em> должен содержать четыре целых    или вещественных значения цветов RGBA, которые определяют цвет фонового    освещения. Значение по умолчанию: (0.0, 0.0, 0.0, 1.0).</p></td>
  </tr>
  <tr>
    <td width="188"><p><strong>GL_DIFFUSE</strong></p></td>
    <td width="417"><p>параметр <em>params</em> должен содержать четыре целых    или вещественных значения цветов RGBA, которые определяют цвет диффузного    освещения. Значение по умолчанию: (1.0, 1.0, 1.0, 1.0) для LIGHT0 и (0.0,    0.0, 0.0, 1.0) для остальных.</p></td>
  </tr>
  <tr>
    <td width="188"><p><strong>GL_SPECULAR</strong></p></td>
    <td width="417"><p>параметр <em>params</em> должен содержать четыре целых    или вещественных значения цветов RGBA, которые определяют цвет зеркального    отражения. Значение по умолчанию: (1.0, 1.0, 1.0, 1.0) для LIGHT0 и (0.0,    0.0, 0.0, 1.0) для остальных.</p></td>
  </tr>
  <tr>
    <td width="188"><p><strong>GL_POSITION</strong></p></td>
    <td width="417"><p>параметр params должен содержать    четыре целых или вещественных, которые определяют положение источника света.    Если значение компоненты w равно 0.0, то источник считается бесконечно    удаленным и при расчете освещенности учитывается только направление на точку    (x,y,z), в противном случае считается, что источник расположен в точке    (x,y,z,w). Значение по умолчанию: (0.0, 0.0, 1.0, 0.0).</p></td>
  </tr>
  <tr>
    <td width="188" valign="top"><p><strong>GL_SPOT_DIRECTION</strong></p></td>
    <td width="417" valign="top"><p>параметр    params должен содержать четыре целых или вещественных числа, которые    определяют направление света. Значение по умолчанию: (0.0, 0.0, -1.0, 1.0). </p></td>
  </tr>
</table>
<p>&nbsp;</p>
<p><strong>Примечание</strong> <br>
  При выключенном освещении цвет  вершины&nbsp;равен&nbsp;текущему цвету, который задается командами <em>glColor*()</em>. При включенном освещении  цвет вершины&nbsp;вычисляется&nbsp;исходя из информации о материале, о нормалях  и об источниках света.<br>
  При выключении освещения визуализация происходит  гораздо быстрее, однако в таком случае приложение должно само рассчитывать  цвета вершин. </p>
<h2><a name="_Toc307897378">1.3&nbsp;</a>Модель освещения<a name="EQSAE"></a></h2>
<p>&nbsp;</p>
<p>В OpenGL используется модель  освещения, в соответствии с которой цвет точки определяется несколькими  факторами: свойствами материала и текстуры, величиной нормали в этой точке, а  также положением источника света и наблюдателя. Для корректного расчета  освещенности в точке надо использовать единичные нормали, однако команды типа <em>glScale*()</em>, могут изменять длину  нормалей. Чтобы это учитывать, используется уже упоминавшийся режим  нормализации нормалей, который включается вызовом команды <em>glEnable(</em>GL_NORMALIZE<em>)</em>.<br>
  Для задания глобальных параметров  освещения используются команды</p>
<p>&nbsp;</p>
<table border="0" cellpadding="0" width="81%">
  <tr>
    <td width="99%"><p>void <strong>glLightModel[i    f](</strong>GLenum pname, GLenum param)<br>
      void <strong>glLightModel[i    f]v</strong>(GLenum pname, const GLtype *params)</p></td>
  </tr>
</table>
<p>Аргумент <em>pname</em> определяет, какой параметр модели освещения будет  настраиваться и может принимать значения, приведенные в таблице.</p>
<p>Таблица &ndash; параметры модели  освещения</p>
<table border="1" cellspacing="0" cellpadding="0" width="614">
  <tr>
    <td width="262"><br>
      <strong>GL_LIGHT_MODEL_LOCAL_VIEWER</strong></td>
    <td width="352" valign="top"><p>параметр    param должен быть булевским и задает положение наблюдателя. Если он равен    FALSE, то направление обзора считается параллельным оси &ndash;z, вне зависимости    от положения в видовых координатах. Если же он равен TRUE, то наблюдатель    находится в начале видовой системы координат. Это может улучшить качество    освещения, но усложняет его расчет. Значение по умолчанию: FALSE. </p></td>
  </tr>
  <tr>
    <td width="262"><p><strong>GL_LIGHT_MODEL_TWO_SIDE</strong></p></td>
    <td width="352" valign="top"><p>параметр    param должен быть булевским и управляет режимом расчета освещенности как для    лицевых, так и для обратных граней. Если он равен FALSE, то освещенность    рассчитывается только для лицевых граней. Если же он равен TRUE, расчет    проводится и для обратных граней. Значение по умолчанию: FALSE. </p></td>
  </tr>
  <tr>
    <td width="262" valign="top"><p><strong>GL_LIGHT_MODEL_AMBIENT</strong></p></td>
    <td width="352" valign="top"><p>параметр    params должен содержать четыре целых или вещественных числа, которые    определяют цвет фонового освещения даже в случае отсутствия определенных    источников света. Значение по умолчанию: (0.2, 0.2, 0.2,1.0). </p></td>
  </tr>
</table>
<strong><br clear="all">
</strong>
<h1>2&nbsp;ПРИМЕР АНИМИРОВАННОГО  ПРИЛОЖЕНИЯ OpenGL </h1>
<p>&nbsp;</p>
<p>В данном разделе будет  рассмотрено приложение, отображающее вращающийся куб. Полный исходный текст  приложения приведен в приложении Г.<br>
  Инициализация окна  приложения происходит в функции main. Здесь  задаются обработчики всех интересующих событий.<br>
  Функция <em>ReshapeFunction</em> отвечает за настройки текущей сцены: </p>
<p>void ReshapeFunction(int width, int height)<br>
  {<br>
  &nbsp;&nbsp;&nbsp; glViewport(0, 0, width, height);</p>
<p>&nbsp;&nbsp;&nbsp; //Установка режима отсечения невидимых  граней<br>
  &nbsp;&nbsp;&nbsp; glDepthFunc(GL_LESS);<br>
  &nbsp;&nbsp;&nbsp; glEnable(GL_DEPTH_TEST);</p>
<p>&nbsp;&nbsp;&nbsp; //Настройка проекции <br>
  &nbsp;&nbsp;&nbsp; glMatrixMode(GL_PROJECTION);<br>
  &nbsp;&nbsp;&nbsp; glLoadIdentity();<br>
  &nbsp;&nbsp;&nbsp; gluPerspective(45.0f,(GLfloat)WindowWidth/(GLfloat)WindowHeight, <br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0.1f,100.0f);</p>
<p>&nbsp;&nbsp;&nbsp; glMatrixMode(GL_MODELVIEW);</p>
<p>&nbsp;&nbsp;&nbsp; //Настройка освещения <br>
  &nbsp;&nbsp;&nbsp; glLightfv(GL_LIGHT1,  GL_AMBIENT, LightAmbient);<br>
  &nbsp;&nbsp;&nbsp; glLightfv(GL_LIGHT1,  GL_DIFFUSE, LightDiffuse);<br>
  &nbsp;&nbsp;&nbsp; glLightfv(GL_LIGHT1,  GL_POSITION, LightPosition);<br>
  &nbsp;&nbsp;&nbsp; glEnable(GL_LIGHTING);<br>
  &nbsp;&nbsp;&nbsp; glEnable(GL_LIGHT1);<br>
  &nbsp;&nbsp;&nbsp; glEnable(GL_COLOR_MATERIAL);</p>
<p>&nbsp;&nbsp;&nbsp; WindowWidth =  width;<br>
  &nbsp;&nbsp;&nbsp; WindowHeight  = height;<br>
  }</p>
<p>Команды <em>glDepthFunc</em> и <em>glEnable</em> отвечают за отсечение невидимых граней. Таким образом грани, которые  скрыты за другими гранями, не будут отрисованы на экране. <br>
  Команды <em>glLightfv</em> и <em>glEnable</em> отвечают за настройку освещения текущей сцены <br>
  В конце функции <em>ReshapeFunction</em> переменным <em>WindowWidth</em> и <em>WindowHeight</em> задаются текущие  значения ширины и высоты окна <br>
  Функция <em>TimerFunction</em> отвечает за перерисовку окна по истечению указанного  промежутка времени. Функция включаек в себя 2 команды:</p>
<p>glutPostRedisplay();&nbsp; <br>
  glutTimerFunc(40,  TimerFunction, 0);</p>
<p>Команда <em>glutPostRedisplay</em> помечает  текущее окно как нуждающееся в перерисовке, что означает, что при первой  возможности будет вызвана функция <em>DrawGLScene</em>. В  следующей команде инициализируется новый таймер, который сработает &nbsp;только один раз через 40 миллисекунд (что в  процессе работы приложения обеспечит частоту смены кадров примерно равной 25).<br>
  Функция <em>DrawGLScene</em> отвечает за построение текущей сцены. Команда <em>glClear</em> производит очистку экрана и буфера глубины. Следующая  команда <em>glPushMatrix</em> сохраняет  текущую видовую матрицу, которая будет восстановлена по окончании построения  всех объектов сцены. Далее команды <em>glTranslatef</em> и <em>glRotatef</em> производят перенос вдоль  оси <em>z</em> и поворот вдоль  осей <em>y</em> и <em>z</em> текущей видовой матрицы соответственно. Данные  изменения видовой матрицы будут применены ко всем объектам, построенным до  команды glPopMatrix. Далее следует построение куба. В качестве базового строительного блока  был выбран примитив четырехугольник (GL_QUADS). Таким образом открывающаяся операторная скобка  примет следующий вид</p>
<p>glBegin(GL_QUADS);</p>
<p>В дальнейшем для отрисовки куба необходимо нарисовать  шесть граней (четырехугольников). Для каждой грани необходимо определить  координаты вершин (четырех), цвет и направление нормали (указание нормали  необходимо для корректного отражения света, падающего на грань). Код для  отрисовки верхней грани куба представлен ниже. </p>
<p>glColor3f(0.0f, 1.0f, 0.0f);<br>
  glNormal3f( 0.0f, 1.0f, 0.0f);<br>
  glVertex3f( edge, edge, -edge);<br>
  glVertex3f(-edge, edge, -edge);<br>
  glVertex3f(-edge, edge,&nbsp; edge);<br>
  glVertex3f( edge, edge,&nbsp; edge);</p>
<p>Команда <em>glColor</em><em>3</em><em>f</em> указывает цвет вершин грани (в данном случае  зеленый). Команда <em>glNormal</em><em>3</em><em>f</em> указывает, что нормаль направлена вверх вдоль оси <em>y</em>.<br>
  По окончании построения всех граней операторная скобка  закрывается вызовом команды <em>glEnd</em>.<br>
  Функция <em>DrawGLScene</em> завершается вызовом функции <em>glutSwapBuffers</em>, которая выводит на экран &laquo;теневой&raquo; буфер, в котором происходила отрисовка  текущей сцены. Вызов данной функции обусловлен необходимостью избежать мерцания  изображения на экране. Данная функция будет работать, если при инициализации  окна в функции <em>glutInitDisplayMode</em> был задан флаг GLUT_DOUBLE (двойная буферизация).</p>
<p><strong>Дополнительно изучить</strong> материал на <a href="../../extra_books/Компьютерная графика_С.М. Брундасов.pdf">стр. 229-237 Учебного пособия С.М. Брундасова &quot;Компьютерная графика&quot;</a></p>
<p>&nbsp;</p>
<p><a href="../../presentations/3-5 лекции Open GL.ppt" target="_new">Презентация к лекциям 3-5</a></p>
</body>
</html>
