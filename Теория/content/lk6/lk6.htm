<!-- (C) 2016 Хаджинова Н.В., каф. ИТАС, БГУИР -->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//RU">
<HTML>
<HEAD>
<LINK rel=stylesheet href="Оболочка/css/style.css" type=text/css>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=windows-1251">
<META HTTP-EQUIV="Content-Language" CONTENT="ru">
<title>Лекция № 6 &quot;Алгоритмы растеризации&quot;</title>
</head>

<body>
<div align="center">
  <h1>Лекция № 6 &quot;<strong>Алгоритмы растеризации</strong>&quot; </h1>
</div>
<hr>
<h2>Темы, рассматриваемые в данной лекции: </h2>
<ol>
  <li>Понятие растеризации. Связанность пикселей.</li>
  <li>Растровое представление отрезка. Простейшие алгоритмы построения отрезков. Алгоритм Брезенхейма для растеризации отрезка.</li>
  <li>Растровое представление окружности. Алгоритм Брезенхейма для растеризации окружности.</li>
  <li>Кривые Безье первого второго, третьего порядка. Метод де Касталье.</li>
  <li>Закраска области заданной цветом границы.</li>
  <li>Отсечение многоугольников (алгоритм Сазерленда-Ходгмана). Заполнение многоугольников.<hr>
  </li>
</ol>
<h2>1.1. Алгоритмы вычерчивания отрезков</h2>
<p>Подавляющее число графических устройств являются растровыми,  представляя изображение в виде прямоугольной матрицы пикселов (растра). Процесс  определения пикселов, наилучшим образом аппроксимирующих заданный отрезок,  называется разложением в растр.<br>
  Алгоритмы рисования отрезков должны удовлетворять следующим  требованиям:</p>
<ul>
  <li>отрезки  должны выглядеть прямыми;</li>
  <li>отрезки  должны начинаться и заканчиваться в заданных точках;</li>
  <li>яркость  отрезка должна быть постоянной и не зависеть от длины и наклона;</li>
  <li>алгоритмы  обязаны работать быстро.</li>
</ul>
<p>Не все из перечисленных критериев могут быть полностью  удовлетворены. Сама природа растрового дисплея исключает генерацию абсолютно  прямых линий (кроме ряда специальных случаев), равно как и точное совпадение  начала и конца отрезка с заданными точками. Тем не менее, при достаточно  высоком разрешении дисплея можно получить приемлемую аппроксимацию.<br>
  Постоянная вдоль всего отрезка яркость сохраняется лишь при  проведении горизонтальных, вертикальных и наклоненных под углом 45&deg;  прямых. Даже для частных случаев яркость зависит от наклона, так как расстояние  между соседними пикселами для отрезка под углом 45&deg; больше, чем для  вертикальных и горизонтальных прямых. Обеспечение одинаковой яркости вдоль  отрезков разных длин требует извлечения квадратного корня, что существенно  замедляет вычисления. Обычным компромиссом является нахождение приближенной  длины отрезка, сведение вычислений к минимуму, предпочтительное использование  целой арифметики, а также реализация алгоритмов на аппаратном и  микропрограммном уровне.<br>
  В большинстве алгоритмов используется пошаговый метод.</p>
<h3>1.1.1. Алгоритм Брезенхема</h3>
<p>Данный алгоритм выбирает оптимальные растровые координаты  для представления отрезка в зависимости от его углового коэффициента. В  процессе работы одна из координат &ndash; либо, x либо y (в зависимости от углового  коэффициента) &ndash; изменяется на единицу. Изменение другой координаты зависит от  расстояния между действительным положением отрезка и ближайшими координатами сетки.  Такое расстояние назовем погрешностью. Для работы алгоритма важен лишь знак  ошибки. <br>
  На рис.11 это иллюстрируется для отрезка в первом октанте,  т.е. для отрезка с угловым коэффициентом, лежащим в пределах от нуля до  единицы. Из рисунка можно заметить, что если угловой коэффициент отрезка из  точки (0, 0) больше чем 1/2, то его пересечение с прямой x = 1 будет  расположено ближе к прямой y = 1, чем к прямой y = 0. Следовательно, точка  растра (1, 1) лучше аппроксимирует ход отрезка, чем точка (1, 0). Если угловой  коэффициент меньше 1/2, то верно обратное.<br>
  Не все отрезки проходят через точки растра. Подобная  ситуация иллюстрируется рис.12, где отрезок с тангенсом угла наклона 3/8  сначала проходит через точку растра (0, 0) и последовательно пересекает три пиксела.  Также демонстрируется вычисление погрешности при представлении отрезка  дискретными пикселами. Так как желательно поверять только знак погрешности, то  первоначально она устанавливается равной -1/2. Таким образом, если угловой  коэффициент отрезка больше или равен 1/2, то величина погрешности в следующей  точке растра с координатами (1, 0) может быть вычислена как e = e + k, где k &ndash; угловой  коэффициент. В нашем случае при первоначальном значении погрешности -1/2  очередное ее значение будет равно e = -1/2 + 3/8 = -1/8. Так как e  отрицательно, отрезок пройдет ниже середины пиксела. Следовательно, пиксел на  том же самом горизонтальном уровне лучше аппроксимирует положение отрезка,  поэтому y не увеличивается. Аналогично вычисляется погрешность в следующей точке  растра: e = -1/8 + 3/8 = 1/4. Теперь e положительно, а значит, отрезок пройдет  выше средней точки. Растровый элемент (2, 1) со следующей по величине  координатой y лучше аппроксимирует положение отрезка.<br>
  <img width="377" height="333" src="lk4_clip_image002.jpg"> <br>
  <img width="262" height="349" src="lk4_clip_image003.gif"><br>
  Следовательно y увеличивается на единицу. Прежде чем  рассматривать следующий пиксел необходимо откорректировать ошибку вычитанием из  нее единицы: e = 1/4 &ndash; 1 = -3/4, после чего процесс вычислений продолжается.  Таким образом, погрешность &ndash; это интервал, отсекаемый по оси y рассматриваемым  отрезком в каждом растровом элементе (относительно -1/2). Ниже показана  реализация алгоритма Брезенхема для первого октана, т.е. для случая 0 &pound; &Delta;y  &le;&Delta;x. Результат работы обсуждаемого алгоритма показан на рис.13.</p>
<p align="center"><img width="197" height="222" src="lk4_clip_image002_0000.jpg"></p>
<p>void line(point&amp; p1, point&amp; p2)<br>
  {<br>
  &nbsp;&nbsp;&nbsp;&nbsp; point p&nbsp; =  p1;<br>
  &nbsp;&nbsp;&nbsp;&nbsp; int dx&nbsp;&nbsp; =  p1.dx(p2), dy = p1.dy(p2);<br>
  &nbsp;&nbsp;&nbsp;&nbsp; double e =  (double)dy/dx &ndash; .5f;<br>
  &nbsp;&nbsp;&nbsp;&nbsp; <br>
  &nbsp;&nbsp;&nbsp;&nbsp; for ( int i = 0; i &lt; dx; i++ )<br>
  &nbsp;&nbsp;&nbsp;&nbsp; {<br>
  &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; plot(p);<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while ( e &gt;= 0 )<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; p.y++;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; e--;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; p.x++;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; e += (double)dy/dx;<br>
  &nbsp;&nbsp;&nbsp;&nbsp; }<br>
  }</p>
<h3>1.1.2. Целочисленный алгоритм Брезенхема</h3>
<p>Быстродействие рассмотренного алгоритма Брезенхема можно  увеличить, если использовать только целочисленную арифметику и исключить  деление. Так как важен, только знак ошибки, то простое преобразование e' =  2e*&Delta;x превратит предыдущий алгоритм в целочисленный и позволит эффективно  реализовать его на аппаратном или микропрограммном уровне. Модифицированный  целочисленный алгоритм для первого октанта имеет вид. </p>
<p>void line(point&amp; p1, point&amp; p2)<br>
  {<br>
  &nbsp;&nbsp;&nbsp;&nbsp; point p&nbsp; =  p1;<br>
  &nbsp;&nbsp;&nbsp;&nbsp; int dx&nbsp;&nbsp; =  p1.dx(p2), dy = p1.dy(p2);<br>
  &nbsp;&nbsp;&nbsp;&nbsp; int e&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; =  (dy &lt;&lt; 1) &ndash; dx;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp; for ( int i = 0; i &lt; dx; i++ )<br>
  &nbsp;&nbsp;&nbsp;&nbsp; {<br>
  &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; plot(p);<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while ( e &gt;= 0 )<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; p.y++;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; e -= (dx &lt;&lt; 1);<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; p.x++;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; e += (dy &lt;&lt; 1);<br>
  &nbsp;&nbsp;&nbsp;&nbsp; }<br>
  } </p>
<h3>1.1.3. Общий алгоритм Брезенхема</h3>
<p>Для реализации алгоритма во всех октантах необходимо  учитывать номер квадранта, в котором лежит отрезок и его угловой коэффициент.  Когда абсолютная величина углового коэффициента больше 1, y постоянно  изменяется на единицу, а критерий погрешности используется для принятия решения  об изменении величины x. Выбор постоянно изменяющейся (на +1 или -1) координаты  зависит от квадранта. </p>
<p>void line(point&amp; p1, point&amp; p2)<br>
  {<br>
  &nbsp;&nbsp;&nbsp;&nbsp; int  dx = abs(p1.dx(p2)), dy = abs(p1.dy(p2));<br>
  &nbsp;&nbsp;&nbsp;&nbsp; int sx = sign(p1.dx(p2)), sy =  sign(p1.dy(p2));<br>
  &nbsp;&nbsp;&nbsp;&nbsp; bool change;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp; if ( change = (dy &gt; dx) )<br>
  &nbsp;&nbsp;&nbsp;&nbsp; {<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int dtemp = dy;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dy = dx;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dx = dtemp;<br>
  &nbsp;&nbsp;&nbsp;&nbsp; }</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp; int dx2 = dx &lt;&lt; 1, dy2 = dy &lt;&lt;  1;<br>
  &nbsp;&nbsp;&nbsp;&nbsp; int e = dy2 &ndash; dx;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp; for ( int i = 0; i &lt; dx; i++ )<br>
  &nbsp;&nbsp;&nbsp;&nbsp; {<br>
  &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; plot(p1);<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while ( e &gt;= 0 )<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( change )<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; p1.x += sx;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; p1.y += sy;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; e -= dx2;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if ( change )<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; p1.y += sy;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; p1.x += sx;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; e += dy2;<br>
  &nbsp;&nbsp;&nbsp;&nbsp; }<br>
  } </p>
<p>&nbsp;</p>
<h2>1.2. Алгоритм  Брезенхема генерации окружности</h2>
<p>Один из наиболее эффективных и простых для понимания  алгоритмов генерации окружности принадлежит Брезенхему. Непосредственно  генерировать необходимо только одну восьмую часть окружности. Остальные ее  части могут быть получены последовательными отражениями относительно прямых x =  y, x = 0 и y=0. Для демонстрации алгоритма рассмотрим первую четверть  окружности с центром в начале координат. Работа алгоритма начинается в точке  x=0, y=R и осуществляется по часовой стрелке. При этом y является монотонно  убывающей функцией аргумента x. <br>
  Для любой заданной точки на окружности при генерации по  часовой стрелке существует только три возможности выбрать следующий пиксел,  наилучшим образом приближающий окружность: горизонтально вправо, по диагонали  вниз и вправо, вертикально вниз. На рис.14 эти направления обозначены  соответственно mh, md, mv. <br>
  <img width="288" height="268" src="lk4_clip_image004.jpg">Алгоритм выбирает пиксел, для которого минимален квадрат  расстояния между одним из этих пикселов и окружностью, т.е. минимум из<br>
mh = |(xi + 1)2 + yi2  &ndash; R2|<br>
md = |(xi + 1)2 + (yi  &ndash; 1)2 &ndash; R2|<br>
mv = |xi2 + (yi &ndash; 1)2  &ndash; R2|<br>
Вычисления можно упростить, если заметить, что в окрестности  точки (xi, yi) возможны только пять типов пересечений  окружности и сетки растра, приведенных на рис.15. Разность между квадратами  расстояний от центра окружности до диагонального пиксела (xi+1, yi-1)  и от центра до точки на окружности R2 равна<br>
&Delta;i = (xi + 1)2 + (yi &ndash;  1)2 &ndash; R2<br>
<img width="298" height="251" src="lk4_clip_image002_0001.jpg"> <br>
Для выбора соответствующего пиксела желательно использовать  только знак погрешности, а не ее величину. При &Delta;i &lt; 0 диагональная  точка (xi+1, yi-1) находится внутри реальной окружности  (случаи 1 и 2 на рис.15). Ясно, что в этой ситуации следует выбрать либо пиксел  (xi+1, yi), т.е. mh, либо пиксел (xi+1,  yi-1), т.е. md. Для этого вначале рассмотрим случай 1 и  проверим разность квадратов расстояний от окружности до пикселов в  горизонтальном и диагональном направлениях:<br>
&delta; = |(xi + 1)2 + yi2  &ndash; R2| &ndash; |(xi + 1)2 + (yi &ndash; 1)2  &ndash; R2|<br>
При &delta;&lt;0 расстояние от окружности до диагонального пиксела  (md) больше, чем до горизонтального (mh). Таким образом,<br>
при &delta;&le;0 выбирается mh в (xi+1, yi)<br>
при &delta;&gt;0 выбирается md в (xi+1, yi-1)<br>
При &delta;&le;0, когда расстояние до окружности до обоих пикселов  одинаковы, выбирается горизонтальный шаг. Так как<br>
(xi + 1)2 + yi2  &ndash; R2 &ge; 0<br>
(xi + 1)2 + (yi &ndash; 1)2  &ndash; R2 &lt; 0<br>
то &delta; можно вычислить по формуле<br>
&delta; = (xi + 1)2 + yi2  &ndash; R2 + (xi + 1)2 + (yi &ndash; 1)2  &ndash; R2<br>
Дополнение до полного квадрата члена yi2 с  помощью добавления и вычитания -2yi + 1 дает<br>
&delta; = 2[(xi + 1)2 + (yi &ndash; 1)2  &ndash; R2] + 2yi &ndash; 1<br>
В квадратных скобках стоит по определению и его подстановка  существенно упрощает выражение<br>
&delta; = 2(&Delta;i + yi) &ndash; 1<br>
Для случая 2 должен быть выбран горизонтальный пиксел, так  как y является монотонно убывающей функцией. Для этого случая &delta; всегда меньше 0  и при использовании того же самого критерия, что и в случае 1, выбирается  пиксел (xi+1, yi).<br>
Если &Delta;i &gt; 0, то диагональная точка находится  вне окружности, т.е. это случаи 3 и 4. Аналогично разбору предыдущего случая  получаем следующее выражение для оценки критерия выбора<br>
&delta;' = 2(&Delta;i + xi) &ndash; 1<br>
Верны следующие зависимости на основе критерия выбора<br>
при &delta;'&le;0 выбирается md в (xi+1, yi-1)<br>
при &delta;'&gt;0 выбирается mv в (xi, yi-1)<br>
В случае 5 (&Delta;i = 0) однозначно выбирается  диагональный пиксел.<br>
Подводя итог, получаем следующие зависимости:<br>
&Delta;i&lt;0<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &delta;&le;0 выбирается пиксел (xi+1, yi) &rarr;  mh<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &delta;&gt;0 выбирается пиксел (xi+1, yi-1)  &rarr; md<br>
&Delta;i&gt;0<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &delta;&le;0 выбирается пиксел (xi+1, yi-1)  &rarr; md<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &delta;&gt;0 выбирается пиксел (xi, yi-1)  &rarr; mv<br>
&Delta;i=0<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; выбирается пиксел (xi+1, yi-1) &rarr; md<br>
В результате работы алгоритма, реализация которого приведена  ниже, будет сгенерирована дуга только в первом квадранте. </p>
<p>void circle(point&amp; p, int R)<br>
  {<br>
  &nbsp;&nbsp;&nbsp;&nbsp; int xi = 0, yi = R, di = (1 &ndash; R) &lt;&lt;  1, limit = 0;<br>
  &nbsp;&nbsp;&nbsp;&nbsp; <br>
  &nbsp;&nbsp;&nbsp;&nbsp; do<br>
  &nbsp;&nbsp;&nbsp;&nbsp; {<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; point p1(p.x+xi, p.y+yi);<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; plot(p1);</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if ( yi &lt;= limit )<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if ( di &lt; 0 )<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if ( ((di&lt;&lt;1) +  (yi&lt;&lt;1) &ndash; 1) &lt;= 0 )<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; di += (++xi&lt;&lt;1) + 1;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; continue;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; di += (++xi&lt;&lt;1) &ndash; (--yi&lt;&lt;1)  + 2;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; continue;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if ( di &gt; 0 )<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if ( ((di&lt;&lt;1) &ndash; (xi&lt;&lt;1)  &ndash; 1) &lt;= 0 )<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; di += (++xi&lt;&lt;1) &ndash; (--yi&lt;&lt;1)  + 2;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; continue;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; di -= (--yi&lt;&lt;1) &ndash; 1;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; continue;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; di += (++xi&lt;&lt;1) &ndash; (--yi&lt;&lt;1)  + 2;<br>
  &nbsp;&nbsp;&nbsp;&nbsp; }<br>
  &nbsp;&nbsp;&nbsp;&nbsp; while ( true );<br>
  }</p>
<h2>1.3. Построение  кривых</h2>
<h3>1.3.1. Кривая Безье</h3>
<p>Разработана математиком Пьером Безье. Кривые и поверхности  Безье Были использованы в 60-х годах компанией &laquo;Рено&raquo; для компьютерного  проектирования формы кузовов автомобилей. В настоящее время они широко  используются в компьютерной графике.<br>
  Кривые Безье описываются в параметрической форме:</p>
<p align="center"><em>x = Px(t),</em><br>
  <em>y = Py(t).</em></p>
<p>Значение <em>t</em> выступает как параметр,  которому отвечают координаты отдельной точки линии. Параметрическая форма  описания может быть более удобной для некоторых кривых, чем задание в виде  функции <em>y = </em><em>f(</em><em>x)</em>. Это потому, что функция <em>f(</em><em>x)</em> может быть намного сложнее, чем <em>Px(</em><em>x)</em> и <em>Py(</em><em>y)</em>, кроме  того, <em>f(</em><em>x)</em> может быть неоднозначной.<br>
  Многочлены Безье для Px и Py  имеют такой вид:</p>
<p align="center"><img width="211" height="107" src="lk4_clip_image004.gif"></p>
<p>где <em>Cmi</em> &ndash; сочетание <em>m</em> по <em>i</em> (известное также по биному Ньютона), <em>Cmi = </em><em>m!/(</em><em>i!(</em><em>m-</em><em>i)!)</em>, а <em>xi</em> и <em>yi</em> &ndash; координаты точек-ориентиров <em>Pi</em>. Значение <em>m</em> можно рассматривать и  как степень полинома, и как значение, которое на единицу меньше количества  точек-ориентиров.<br>
  Рассмотрим кривые Безье, классифицируя их по значениям <em>m</em>.<br>
  <strong><u>m = 1</u></strong> (по двум точкам, рис. 0.0)<br>
  Кривая вырождается в отрезок прямой линии, определяемый  концевыми точками <em>P0</em> и <em>P1</em>,  как показано на рисунке.<br>
  <em>P(t) = (1 - t)P0 + t P1</em>.</p>
<p align="center"><img width="328" height="124" src="lk4_clip_image005.gif"><br>
  Рис.  3.х</p>
<p><strong><u>m = 2</u></strong> (по трем точкам, рис. 0.0)<br>
  <em>P(t) = (1 - t)2P0 + 2t(1 - t)P1 + t2P2</em>.</p>
<p align="center"><img width="256" height="256" src="lk4_clip_image006.gif"><br>
  Рис.  3.х</p>
<p><strong><u>m = 3</u></strong> (по четырем точкам)<br>
  <em>P(t) = (1 - t)3P0 + 3t(1 - t)2P1  + 3t(1 - t)2P2 + t3P3</em>.</p>
<p align="center"><img width="560" height="384" src="lk4_clip_image007.gif"> <br>
  Рис.  3.х</p>
<h3>1.3.2. Геометрический алгоритм для кривой Безье</h3>
<p>Этот алгоритм позволяет вычислить координаты <em>(</em><em>x, </em><em>y)</em> точки  кривой Безье по значению параметра <em>t</em>.</p>
<ol>
  <li>Каждая  сторона контура многоугольника, проходящего по точкам ориентирам, делится  пропорционально значению <em>t</em>.</li>
  <li>Точки  деления соединяются отрезками прямых и образуют новый многоугольник. Количество  узлов нового контура на единицу меньше, чем количество узлов предыдущего  контура.</li>
  <li>Стороны  нового контура снова делятся пропорционально значению <em>t</em>. И так  далее. Это продолжается до тех пор, пока не будет получена единственная точка  деления. Эта точка и будет точкой кривой Безье для заданного параметра <em>t</em>.</li>
</ol>
<p align="center"><img width="257" height="203" src="lk4_clip_image008.gif"><img width="303" height="208" src="lk4_clip_image009.gif"><br>
  Рис. 3.х. Геометрический алгоритм для кривых  Безье</p>
<p>Приведем запись  геометрического алгоритма на языке C++:</p>
<p>POINT P[M+1]; //массив точек ориентиров<br>
  ...<br>
  //формируем вспомогательный массив R[]<br>
  POINT R[M+1];<br>
  for ( i = 0; i &lt;=  m; i++) R[i] = P[i];<br>
  for { j = m; j &gt;  0; j--)<br>
  &nbsp;&nbsp;&nbsp;&nbsp; for ( i = 0; i &lt; j; i++)<br>
  &nbsp;&nbsp;&nbsp;&nbsp; {<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; R[i].x = R[i].x + t * (R[i+1].x - R[i].x);<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; R[i].y = R[i].y + t * (R[i+1].y - R[i].y);<br>
  &nbsp;&nbsp;&nbsp;&nbsp; }</p>
<p>Результат работы  алгоритма &ndash; координаты одной точки кривой Безье &ndash; записываются в R[0].<br>
  Замечание: данный пример страдает тем недостатком, что  параметр <em>t</em> является вещественным числом, а  координаты точек ориентиров целые числа. Поэтому целесообразнее представлять  координаты точек в виде вещественных чисел, а при выводе преобразовывать их  (например, путем округления) в целые величины.</p>
<h2>1.4. Стиль линии. Перо</h2>
<p>Что общее и что  разное у объектов, изображенных на рис. 3.18?</p>
<p align="center"><img width="362" height="205" src="lk4_clip_image001.gif"><br>
  Рис. 3.х. Примеры стилей линий</p>
<p>Общее &ndash; линия оси,  описывающая каждый из восьми объектов. Разное &ndash; элементы вдоль линии оси. Для  описания различных по виду изображений на основе линий используют термин стиль линий или перо. Термин перо иногда делает более понятной суть алгоритма вывода линий  для некоторых стилей &ndash; в особенности для толстых линий. Например, если для  тонкой непрерывной линии перо соответствует одному пикселу, то для толстых  линий перо можно представить себе как фигуру или отрезок линии, который  скользит вдоль оси линии, оставляя за собой след (табл. 3.х).</p>
<p>Таблица 3.х</p>
<table border="1" cellspacing="0" cellpadding="0">
  <tr>
    <td width="113" valign="top"><br>
      Форма пера </td>
    <td width="113" valign="top"><p align="center">&ndash;</p></td>
    <td width="113" valign="top"><p align="center">|</p></td>
    <td width="113" valign="top"><p align="center">/</p></td>
    <td width="113" valign="top"><p align="center">g </p></td>
    <td width="113" valign="top"><p align="center">n </p></td>
  </tr>
  <tr>
    <td width="113" valign="top"><p>Результат</p></td>
    <td width="113" valign="top"><p align="center"><img width="52" height="64" src="lk4_clip_image003.jpg"></p></td>
    <td width="113" valign="top"><p align="center"><img width="54" height="64" src="lk4_clip_image005.jpg"></p></td>
    <td width="113" valign="top"><p align="center"><img width="56" height="64" src="lk4_clip_image007.jpg"></p></td>
    <td width="113" valign="top"><p align="center"><img width="57" height="64" src="lk4_clip_image009.jpg"></p></td>
    <td width="113" valign="top"><p align="center"><img width="52" height="64" src="lk4_clip_image011.jpg"></p></td>
  </tr>
</table>
<h3>1.4.1. Алгоритмы вывода толстой линии</h3>
<p>Взяв за основу любой  алгоритм вывода обычных тонких линий (например, алгоритм Брезенхема), запишем  его в следующем обобщенном виде:<br>
  &hellip;<br>
  Вывод пиксела <em>(х,  у)</em><br>
  &hellip;<br>
  Можно представить  себе такой алгоритм, как цикл, в котором определяются координаты <em>(х, у)</em> каждого пиксела. Этот алгоритм можно  модифицировать для вывода толстой линии следующим образом:<br>
  &hellip;<br>
  Вывод фигуры (или  линии) пера с центром <em>(</em><em>x</em><em>, </em><em>y</em><em>)</em> <br>
  &hellip;<br>
  Вместо вывода  отдельного пиксела стоит вывод фигуры или линии, соответствующей перу &ndash;  прямоугольник, круг, отрезок прямой.<br>
  Такой подход к  разработке алгоритмов толстых линий имеет преимущества и недостатки.  Преимущество &ndash; можно прямо использовать эффективные алгоритмы для вычисления  координат точек линии оси, например, алгоритмы Брезенхема. Недостаток &ndash;  неэффективность для некоторых форм пера. Для перьев, которые соответствуют  фигурам с заполнением, количество тактов работы алгоритма пропорционально  квадрату толщины линии. При этом большинство пикселов многократно закрашивается  в одних и тех же точках (рис. 3.х).</p>
<p align="center"><img width="376" height="118" src="lk4_clip_image013.jpg"><br>
  Рис. 3.х. Прямоугольное и круглое перья  работают избыточно</p>
<p>Такие алгоритмы  более эффективны для перьев в виде отрезков линий. В этом случае каждый пиксел  рисуется только один раз. Но здесь важным является наклон изображаемой линии.  Ширина пера зависит от наклона (рис. 3.х).<br>
  Очевидно,  горизонтальное перо не может рисовать толстую горизонтальную линию.</p>
<p align="center"><img width="447" height="155" src="lk4_clip_image015.jpg"><br>
  Рис. 3.х. Перья в виде отрезков линий</p>
<p>Для вывода толстых  линий с помощью пера в качестве отрезка линии чаще всего используются отрезки  горизонтальной или вертикальной линий, реже &ndash; диагональные отрезки под углом 45  градусов. Целесообразность использования такого способа определяется большой  скоростью вывода горизонтальных и вертикальных отрезков прямой. Для того чтобы  достигнуть минимального количества тактов вывода, толстые линии, которые по  наклону ближе к вертикальным, рисуют горизонтальным пером, а пологие линии &ndash;  вертикальным пером.<br>
  При выводе толстых  линий с использованием пера-отрезка линии заметны разрывы в углах полилиний и  плохие концы (рис. 3.х).</p>
<p align="center"><img width="420" height="103" src="lk4_clip_image017.jpg"><br>
  Рис. 3.х. Вывод толстых линий с  использованием пера-отрезка</p>
<p>Для решения таких  проблем иногда используют другие алгоритмы вывода толстых линий. Например,  вывод толстой полилинии можно выполнить как рисование полигона с заполнением  (рис. 3.х).</p>
<p align="center"><img width="388" height="142" src="lk4_clip_image019.jpg"><br>
  Рис. 3.х. Пример толстой полилинии</p>
<p>Очевидный недостаток  такого подхода &ndash; меньшая скорость вывода, поскольку заполнение полигона &ndash; это  существенно более трудоемкая задача, чем вывод линий, а кроме того, нужно еще  определять координаты его вершин.<br>
  Третья разновидность  алгоритмов вывода толстых линий &mdash; рисование толстой линии последовательным  наложением нескольких тонких линий, смещенных одна относительно второй.</p>
<h3>1.4.2. Алгоритмы вывода пунктирной линии</h3>
<p>Алгоритм для  рисования тонкой пунктирной линии можно получить из алгоритма вывода тонкой  непрерывной линии заменой процедуры вывода пиксела более сложной конструкцией:<br>
  &hellip;<br>
  Проверка значения  счетчика <em>С</em>:<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Если <em>С</em> удовлетворяет некоторым условиям, то<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; вывод пиксела <em>(</em><em>x</em><em>, у)</em> <br>
  Значение <em>С</em> увеличивается на единицу.<br>
  &hellip;<br>
  В таком алгоритме  используется новая переменная <em>С</em> &ndash; счетчик пикселов линии. Если значение <em>С</em> удовлетворяет некоторому логическому условию, то рисуется  пиксел заданного цвета с текущими координатами <em>(</em><em>x</em><em>, у)</em>. Логическое условие будет определять стиль линии. Например, если  условием будет четность значения <em>С</em>,  то получим линию из одиночных точек. Для рисования пунктирной линии можно  анализировать остаток от деления <em>С</em> на <em>S</em>. Например,  если рисовать пикселы линии только тогда, когда <em>С </em><em>mod</em><em>S</em><em> &lt; </em><em>S</em><em>/2</em>, то получим пунктирную линию с длиной штрихов <em>S</em><em>/2</em> и с шагом <em>S</em>. <br>
  При выводе  полилиний, которые состоят из отрезков прямых, или сплайновых кривых,  необходимо предотвратить обнуление значения счетчика в начале каждого отрезка и  обеспечить продолжение непрерывного приращения вдоль всей сложной линии. Иначе  будут нестыковки пунктира. Использование переменной-счетчика затруднено при  генерации пунктирных линий в алгоритмах, которые используют симметрию,  например, при выводе круга или эллипса. В этом случае будут нестыковки пунктира  на границах октантов или квадрантов.</p>
<h3>1.4.3. Алгоритм вывода толстой пунктирной линии</h3>
<p>Объединив алгоритм  для вывода толстой непрерывной линии и алгоритм для тонкой пунктирной линии,  можно получить следующий алгоритм:<br>
  &hellip;<br>
  Проверка значения  счетчика <em>С</em>:<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Если <em>С</em> удовлетворяет условию, то<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; вывод фигуры  (линии) пера с центром в <em>(</em><em>x</em><em>, у)</em> <br>
  <em>С = С + </em><em>1</em>;<br>
  &hellip;<br>
  Такой алгоритм  достаточно прост. На практике используются и более изощренные алгоритмы.</p>
<h2>1.5. Заполнение сплошных областей</h2>
<p>Существует несколько методов заполнения сплошных областей,  которые чаще всего делятся на две широкие категории: растровая развертка и  затравочное заполнение. В методах растровой развертки пытаются определить в  порядке сканирования строк, лежит ли точка внутри многоугольника или контура. В  методах затравочного заполнения предполагается, что известна некоторая точка  внутри замкнутого контура.</p>
<h3>1.5.1. Растровая развертка  многоугольников</h3>
<p>Свойство растровых дисплеев, при котором соседние пикселы на  сканирующей строке, вероятно, имеют одинаковые характеристики, называется  когерентностью растровых строк.<br>
  Характеристики пикселов на данной строке изменяются только  там, где ребро многоугольника пересекает строку. Эти пересечения делят строку  на области. При определении интенсивности, цвета и оттенка пикселов на  сканирующей строке рассматриваются пары отсортированных точек пересечения. Для  каждого интервала, задаваемого парой точек пересечения, используется  интенсивность или цвет заполняемого многоугольника.<br>
  Известно несколько достаточно простых и эффективных разновидностей  алгоритмов с упорядоченным списком ребер. Эффективность этих алгоритмов  напрямую зависит от эффективности сортировок.<br>
  Простой алгоритм с упорядоченным списком ребер имеет вид:</p>
<ul>
  <li>Подготовка  данных:</li>
</ul>
<p>Определение для каждого ребра многоугольника точки  пересечений со сканирующими строками, проведенными через середины интервалов,  для чего можно использовать любой из существующих алгоритмов. Горизонтальные  ребра игнорируются. Точка пересечения в вершине многоугольника учитывается два  раза, если она является точкой локального максимума или минимума и один раз в  противном случае. Занести каждое пересечение <em>(</em><em>x, y+1/2)</em> в список. Отсортировать  список по строкам и по возрастанию <em>x</em> в строке.</p>
<ul>
  <li>Преобразование  данных в растровую форму:</li>
</ul>
<p>Выделение из отсортированного списка пары элементов <em>(x1, y1)</em> и <em>(x2, y2)</em>.  Структура списка гарантирует, что <em>y = y1  = y2</em> и <em>x1 &le; x2</em>.  Активизация на сканирующей строке <em>y</em> пикселей для целых  значений <em>x</em>, таких, что <em>x1 &le; </em><em>x + 1/2 &le; </em><em>x2</em>.</p>
<h3>1.3.2. Алгоритмы заполнения с затравкой</h3>
<p>Различают два типа областей для заполнения: внутренне- и  гранично-определенные. Если область относится к внутренне-определенным, то все  пикселы, принадлежащие внутренней части, имеют один и тот же цвет или  интенсивность, а все пикселы, внешние по отношению к области, имеют другой  цвет. Если область относится к гранично-определенной, то все пикселы на границе  области имеют выделенное значение или цвет. Внешние по отношению к границе  пикселы, также могут иметь граничное значение.<br>
  Внутренне- и гранично-определенные области могут быть 4- или  8-связными. Если область 4-связная, то любого пиксела в области можно достичь с  помощью комбинации движений только в 4 направлениях: налево, направо, вверх,  вниз. Для 8-связной области пиксела можно достичь с помощью комбинации движений  в двух вертикальных, двух горизонтальных и 4 диагональных направлениях.  Алгоритм заполнения 8-связной области заполнит и 4-связную область, однако, не  наоборот.<br>
  Ниже будут рассмотрены гранично-заполняющие алгоритмы.  Соответствующие им внутренне-заполняющие алгоритмы получаются аналогичным  образом.<br>
  Большинство алгоритмов заполнения с затравкой основано на  использовании стека. Простейший алгоритм требует большого объема стека, который  содержит дублирующую информацию. Построчный алгоритм минимизирует размер стека  за счет хранения только одного затравочного пиксела для любого непрерывного  интервала на сканирующей строке.<br>
  Схематично работу алгоритма можно разбить на четыре этапа:</p>
<ul>
  <li>Затравочный  пиксел на интервале извлекается из стека, содержащего затравочные пикселы.</li>
  <li>Интервал  с затравочным пикселом заполняется влево и вправо от затравки вдоль сканирующей  строки до тех пор, пока не будет найдена граница.</li>
  <li>В  переменных запоминаются крайний левый и крайний правый пикселы интервала.</li>
  <li>В  диапазоне проверяются строки, расположенные непосредственно над и под текущей  строкой. Определяется, есть ли на них еще не заполненные пикселы. Если такие  пикселы есть (т.е. не все пикселы граничные, или уже заполненные), то в  указанном диапазоне крайний правый пиксел в каждом интервале отмечается как  затравочный и помещается в стек.</li>
  <li>При  инициализации алгоритма в стек помещается единственный затравочный пиксел,  работа завершается при опустошении стека.</li>
</ul>
</body>
</html>
