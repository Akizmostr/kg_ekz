<!-- (C) 2016 Хаджинова Н.В., каф. ИТАС, БГУИР -->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//RU">
<HTML>
<HEAD>
<LINK rel=stylesheet href="Оболочка/css/style.css" type=text/css>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=windows-1251">
<META HTTP-EQUIV="Content-Language" CONTENT="ru">
<title>Лекция № 3 &quot;Спецификация OpenGL. Библиотеки GLUT. Синтаксис. Функции.&quot;</title>
</head>

<body>
<div align="center">
  <h1>Лекция № 3 &quot;<strong>Спецификация OpenGL. OpenGL в Windows.</strong>&quot; </h1>
</div>
<hr>
<h2>Темы, рассматриваемые в данной лекции: </h2>
<ol>
  <li>Языки программирования и графика. Процедуры и       функции работы с точками, линиями, графическими примитивами, палитрой,       шрифтами.</li>
  <li>OpenGL в Windows. Назначение и основные       возможности графической библиотеки OpenGL.</li>
  <li>Библиотеки GLU, GLUT, GLX.<hr>
  </li>
</ol>
<h1><a name="_Toc307897350">1&nbsp;ОСНОВЫ </a>OpenGL </h1>
<h2><a name="_Toc307897351">1.1</a>&nbsp;Архитектура OpenGL </h2>
<p align="center">&nbsp;</p>
<p>Функции OpenGL реализованы в модели  клиент-сервер. Приложение выступает в роли клиента &ndash; оно вырабатывает команды,  а сервер OpenGL интерпретирует и выполняет их. Сам сервер может находиться как  на том же компьютере, на котором находится клиент (например, в виде динамически  загружаемой библиотеки &ndash; DLL), так и на другом (при этом может быть использован  специальный протокол передачи данных между машинами).<br>
  GL обрабатывает и рисует в буфере кадра  графические&nbsp;<em>примитивы</em>&nbsp;с учетом некоторого числа выбранных  режимов. Каждый примитив &ndash; это точка, отрезок, многоугольник и т.д. Каждый  режим может быть изменен независимо от других. Определение примитивов, выбор  режимов и другие операции описываются с помощью&nbsp;<em>команд&nbsp;</em>в форме вызовов функций прикладной  библиотеки.<br>
  Примитивы определяются набором из одной  или более&nbsp;<em>вершин&nbsp;</em>(vertex). Вершина определяет  точку, конец отрезка или угол многоугольника. С каждой вершиной ассоциируются  некоторые данные (координаты, цвет, нормаль, текстурные координаты и т.д.),  называемые&nbsp;<em>атрибутами</em>. В  подавляющем большинстве случаев каждая вершина обрабатывается независимо от  других.<br>
  С точки зрения архитектуры графическая  система OpenGL является конвейером, состоящим из нескольких последовательных  этапов обработки графических данных.<br>
  Команды OpenGL всегда обрабатываются в том  порядке, в котором они поступают, хотя могут происходить задержки перед тем,  как проявится эффект от их выполнения. В большинстве случаев OpenGL  предоставляет непосредственный интерфейс, т.е. определение объекта вызывает его  визуализацию в буфере кадра.<br>
  С точки зрения разработчиков, OpenGL &ndash; это  набор команд, которые управляют использованием графической аппаратуры. Если  аппаратура состоит только из адресуемого буфера кадра, тогда OpenGL должен быть  реализован полностью с использованием ресурсов центрального процессора. Обычно  графическая аппаратура предоставляет различные уровни ускорения: от аппаратной  реализации вывода линий и многоугольников до изощренных графических процессоров  с поддержкой различных операций над геометрическими данными. </p>
<p align="center"><img width="322" height="257" src="lk3_clip_image002.gif"><br>
  <br>
  Рисунок  &ndash; Функционирование конвейера OpenGL </p>
<p>OpenGL является прослойкой между  аппаратурой и пользовательским уровнем, что позволяет предоставлять единый  интерфейс на разных платформах, используя возможности аппаратной поддержки.<br>
  Кроме того, OpenGL можно рассматривать как  конечный автомат, состояние которого определяется множеством значений  специальных переменных и значениями текущей нормали, цвета, координат текстуры  и других атрибутов и признаков. Вся эта информация будет использована при поступлении  в графическую систему координат вершины для построения фигуры, в которую она  входит. Смена состояний происходит с помощью команд, которые оформляются как  вызовы функций.</p>
<h2><a name="_Toc307897352">1.2&nbsp;Основы  синтаксиса </a>OpenGL </h2>
<p>&nbsp;</p>
<p>Перед именами функций <em>основной  библиотеки </em><em>OpenGL</em> (ее еще называют <em>корневой библиотекой </em><em>OpenGL</em><em>)</em> ставится префикс gl,  а каждое слово, которое входит в имя функции, начинается с прописной буквы.  Следующие примеры иллюстрируют такой принцип именования.</p>
<p align="center">glBegin, glClear, glCopyPixels, glPolygonMode </p>
<p>Определенные функции требуют, чтобы одному  (или нескольким) из ее аргументов присваивалось значение символьной константы,  обозначающей, например, имя параметра, значение параметра или определенный режим.  Все такие константы начинаются с прописных букв GL. Кроме того, слова, составляющие имя этой  константы, пишутся приписными, а в качестве разделителя между словами,  составляющими одно имя, используется знак подчеркивания (_). Ниже приведено  несколько примеров из нескольких сотен символьных констант, которые могут использоваться  функциями пакета OpenGL.</p>
<p align="center">GL_2D, GL_RGB,  GL_POLYGON, GL_AMBIENT_AND_DIFFUSE </p>
<p>Функции пакета OpenGL также воспринимают  особые типы данных. Например, параметр функции OpenGL может воспринимать  значения, которые задаются как 32- разрядные целые числа. Но размер  спецификации целого числа на разных машинах может отличаться. Для обозначения  особого типа данных в пакете OpenGL исполь&shy;зуются специальные встроенные  названия типов данных.</p>
<p align="center">GLbyte, GLshort,  GLint, GLfloat, GLdouble, GLboolean </p>
<p>Каждое название типа данных начинается с  прописных букв GL,  а остальная часть названия &ndash; это стандартное обозначение типа данных,  написанное строчными. Сравнение типов данных OpenGL с типами данных C приведено в таблице.</p>
<p>Таблица  &ndash; Типы переменных OpenGL и соответствующие типы данных языка С </p>
<div align="center">
  <table border="1" cellspacing="0" cellpadding="0">
    <tr>
      <td width="184" valign="top"><br>
        <strong>Тип данных </strong><strong>OpenGL</strong></td>
      <td width="213" valign="top"><p><strong>Внутреннее</strong><strong> </strong><strong>представление</strong></p></td>
      <td width="176" valign="top"><p><strong>Определение в форме типа С</strong></p></td>
    </tr>
    <tr>
      <td width="184" valign="top"><p>GLbyte </p></td>
      <td width="213" valign="top"><p>8-битовое целое</p></td>
      <td width="176" valign="top"><p>signed char </p></td>
    </tr>
    <tr>
      <td width="184" valign="top"><p>GLshort </p></td>
      <td width="213" valign="top"><p>16-битовое целое </p></td>
      <td width="176" valign="top"><p>short </p></td>
    </tr>
    <tr>
      <td width="184" valign="top"><p>GLint, GLsizei </p></td>
      <td width="213" valign="top"><p>32-битовое целое </p></td>
      <td width="176" valign="top"><p>long </p></td>
    </tr>
    <tr>
      <td width="184" valign="top"><p>GLfloat, GLclampf </p></td>
      <td width="213" valign="top"><p>32-битовое с плавающей запятой </p></td>
      <td width="176" valign="top"><p>float </p></td>
    </tr>
    <tr>
      <td width="184" valign="top"><p>GLdouble, GLclampd </p></td>
      <td width="213" valign="top"><p>64-битовое с плавающей запятой </p></td>
      <td width="176" valign="top"><p>double </p></td>
    </tr>
    <tr>
      <td width="184" valign="top"><p>GLubyte, GLboolean </p></td>
      <td width="213" valign="top"><p>8-битовое целое без знака </p></td>
      <td width="176" valign="top"><p>unsigned char </p></td>
    </tr>
    <tr>
      <td width="184" valign="top"><p>GLushort </p></td>
      <td width="213" valign="top"><p>16-битовое целое без знака </p></td>
      <td width="176" valign="top"><p>unsigned short </p></td>
    </tr>
    <tr>
      <td width="184" valign="top"><p>GLuint, GLenum, GLbitfield </p></td>
      <td width="213" valign="top"><p>32-битовое целое без знака </p></td>
      <td width="176" valign="top"><p>unsigned long </p></td>
    </tr>
  </table>
</div>
<p>Некоторым аргументам функций OpenGL можно присваивать  значения с помощью массива, который содержит набор значений. Это опция для  спецификации списка значений в виде указателя на массив, а не путем  спецификации каждого элемента из списка явно в виде аргумента параметра.  Характерный пример применения этой опции &ndash; задание значений координат <em>xyz</em><em>.</em></p>
<h2><a name="_Toc307897353">1.3&nbsp;Основные  библиотеки и расширения </a>OpenGL </h2>
<p>&nbsp;</p>
<p>OpenGL  состоит из набора библиотек. Все базовые функции хранятся в основной  библиотеке, для обозначения которой в дальнейшем будет использоваться  аббревиатура GL. Помимо основной, OpenGL включает в себя несколько  дополнительных библиотек.<br>
  Библиотека  утилит GL (GLU &ndash; GL Utility). Все функции этой библиотеки определены через  базовые функции GL. В состав GLU вошла реализация более сложных функций, таких  как набор популярных геометрических примитивов (куб, шар, цилиндр, диск),  функции построения сплайнов, реализация дополнительных операций над матрицами и  т.п.<br>
  Библиотека GLUT (GL Utility Toolkit). Формально  GLUT не входит в OpenGL, но фактически включается почти во все его дистрибутивы  и имеет реализации для различных платформ. GLUT предоставляет только минимально  необходимый набор функций для создания OpenGL-приложения, включая специальные  команды для работы с окнами или ввода информации от пользователя.</p>
<strong><br clear="all">
</strong>
<h1><a name="_Toc307897354">2&nbsp;СОЗДАНИЕ ПРИЛОЖЕНИЯ </a>OpenGL </h1>
<h2><a name="_Toc307897355">2.1&nbsp;Создание  приложения </a>OpenGL при помощи Windows API </h2>
<p><strong>&nbsp;</strong></p>
<h3><a name="_Toc307897356">2.1.1&nbsp;Создание и  настройка проекта приложения в среде </a>Microsoft Visual  Studio </h3>
<p><strong>2.1.1.1&nbsp;Создание  проекта</strong><br>
  1.&nbsp;Выполните команду File&rarr;New&rarr;Project.<br>
  2.&nbsp;В появившемся окне выберите Win32 Project, ведите имя  проекта и нажмите OK.<br>
  3.&nbsp;В окне мастера создания проекта щелкните кнопку  Next, отметьте  флажком пункт Empty Project и нажмите Finish.</p>
<p><strong>2.1.1.2&nbsp;Добавление  исходного файла</strong><br>
  Если необходимо создать новый файл, то необходимо  выполнить следующие действия:<br>
  1.&nbsp;Выполнить команду Project&rarr;Add New Item.<br>
  2.&nbsp;В появившемся окне выбрать C++ File (.cpp), ввести  имя файла и нажать OK.<br>
  Если необходимо добавить существующий файл, то  необходимо выполнить следующие действия:<br>
  1.&nbsp;Выполнить команду Project&rarr;Add Existing Item.<br>
  2.&nbsp;В появившемся окне выбрать нужный  файл и нажать Add.</p>
<p><strong>2.1.1.3  Добавление подключаемых библиотек</strong><br>
  1.&nbsp;Выполните команду Project&rarr;&lt;имя проекта&gt; Properties.<br>
  2.&nbsp;В появившемся диалоговом окне в  левой навигационной панели выберите пункт Configuration Properties&rarr;Linker&rarr;Input.<br>
  3.&nbsp;В верхней части диалогового окна из  выпадающего списка Configuration выберите пункт All Configurations.<br>
  4.&nbsp;В параметр Additional Dependencies добавьте opengl32.lib  и glu32.lib. Нажмите OK.</p>
<h3><a name="_Toc307897357">2.1.2&nbsp;Структура  приложения</a></h3>
<p>&nbsp;</p>
<p>В данном пункте будет рассмотрено создание оконного OpenGL приложения при помощи Windows API.<br>
  Исходный код приложения OpenGL приведен в приложении В.<br>
  В данном приложении определены 7 основных функций:<br>
  &ndash; WinMain<br>
  &ndash; CreateGLWindow<br>
  &ndash; InitGL<br>
  &ndash; ReSizeGLScene<br>
  &ndash; DrawGLScene<br>
  &ndash; KillGLWindow<br>
  &ndash; WndProc<br>
  Функция <em>WinMain</em> является точкой  входа в приложение. Вначале в этой функции производится попытка при помощи  функции <em>CreateGLWindow</em> создать окно приложения. При неудаче функция  завершает своё выполнение и осуществляется выход из программы. В случае удачи  запускается бесконечный цикл, в котором производится диспетчеризация  поступающих системных сообщений, пока не получено сообщение о выходе из  приложения. <br>
  Функция <em>CreateGLWindow</em> создает окно приложения. В случае  удачи функция вернет в функцию <em>WinMain</em> значение <em>true</em> и программа продолжит выполняться.  В данной функции создается и регистрируется класс окна, устанавливается формат  вывода пикселей на экран, производится получение контекста устройства,  контекста рендеринга. Если на каком-либо этапе происходит ошибка, то функция  прекращает выполнение, вызывается функция <em>KillGLWindow</em> &nbsp;и возвращается значение <em>false</em>, что приводит к завершению  выполнения программы.<br>
  Функция <em>KillGLWindow</em> осуществляет освобождение ресурсов,  занятых текущей программой.<br>
  Функция <em>InitGL</em> отвечает за  статические настройки отображения текущей сцены.<br>
  Функция <em>ReSizeGLScene</em> отвечает за настройки отображения текущей сцены, которые могут изменяться  на протяжении времени работы программы. В частности, данная функция вызывается  при изменении размеров окна и его перетаскивании.<br>
  Функция <em>DrawGLScene</em> отвечает за построение текущей  сцены. В ней производится очистка экрана, построение объектов и пр. <br>
  Функция <em>WndProc</em> занимается обработкой входящих системных сообщений, в том числе и нажатий  клавиш. </p>
<h2><a name="_Toc307897358">2.2&nbsp;Создание  приложения </a>OpenGL средствами библиотеки Glut </h2>
<p>&nbsp;</p>
<h3><a name="_Toc307897359">2.2.1</a>&nbsp;Создание и настройка проекта приложения в среде Microsoft Visual Studio </h3>
<p><strong>2.2.1.1&nbsp;Создание  проекта</strong><br>
  1.&nbsp;Выполните команду File&rarr;New&rarr;Project.<br>
  2.&nbsp;В появившемся диалоговом окне  выберите Win32 Console Application, ведите имя  проекта и нажмите OK.<br>
  3.&nbsp;В окне мастера создания проекта  щелкните кнопку Next, отметьте флажком пункт Empty Project и нажмите Finish.</p>
<p><strong>2.</strong><strong>2</strong><strong>.1.2&nbsp;Добавление исходного файла</strong><br>
  Если необходимо создать новый файл, то необходимо  выполнить следующие действия:<br>
  1.&nbsp;Выполнить команду Project&rarr;Add New Item.<br>
  2.&nbsp;В появившемся окне выбрать C++ File (.cpp), ввести  имя файла и нажать OK.<br>
  Если необходимо добавить существующий файл, то  необходимо выполнить следующие действия:<br>
  1.&nbsp;Выполнить команду Project&rarr;Add Existing Item.<br>
  2.&nbsp;В появившемся окне выбрать нужный  файл и нажать Add.</p>
<p><strong>2.</strong><strong>2</strong><strong>.1.3 Добавление подключаемых библиотек</strong><br>
  1.&nbsp;Выполните команду Project&rarr;&lt;имя проекта&gt; Properties.<br>
  2.&nbsp;В появившемся диалоговом окне в  левой навигационной панели выберите пункт Configuration Properties&rarr;Linker&rarr;Input.<br>
  3.&nbsp;В верхней части диалогового окна из  выпадающего списка Configuration выберите пункт All Configurations.<br>
  4.&nbsp;В параметр Additional Dependencies добавьте glut32.lib. Нажмите OK.</p>
<h3>&nbsp;</h3>
<h3><a name="_Toc307897360">2.2.2&nbsp;Структура  приложения</a></h3>
<p>В данном пункте будет  рассмотрено построение консольного приложения при помощи библиотеки GLUT или GL  Utility Toolkit, получившей в последнее время широкое распространение. Эта  библиотека обеспечивает единый интерфейс для работы с окнами вне зависимости от  платформы, поэтому описываемая ниже структура приложения остается неизменной  для операционных систем Windows, Linux и многих других.<br>
  Функции GLUT могут быть  классифицированы на несколько групп по своему назначению:</p>
<ul>
  <li>инициализация; </li>
  <li>начало обработки событий; </li>
  <li>управление окнами; </li>
  <li>управление меню; </li>
  <li>регистрация вызываемых (callback) функций; </li>
  <li>управление индексированной палитрой цветов; </li>
  <li>отображение шрифтов; </li>
  <li>отображение дополнительных геометрических фигур (тор,  конус и др.).</li>
</ul>
<p>Инициализация проводится  с помощью функции</p>
<p><strong>glutInit</strong>(int *argcp, char **argv) </p>
<p>Переменная&nbsp;<em>argcp</em>&nbsp;есть  указатель на стандартную переменную argc описываемую в функции main(), а&nbsp;<em>argv</em>&nbsp;&ndash;  указатель на параметры, передаваемые программе при запуске, который описывается  там же. Эта функция проводит необходимые начальные действия для построения окна  приложения, и только несколько функций GLUT могут быть вызваны до нее. К ним относятся:</p>
<p><strong>glutInitWindowPosition</strong>(int x, int  y)<br>
  <strong>glutInitWindowSize</strong>(int width,  int height)<br>
  <strong>glutInitDisplayMode</strong>(unsigned int mode) </p>
<p>Первые две функции задают  соответственно положение и размер окна, а последняя функция определяет  различные режимы отображения информации, которые могут совместно задаваться с  использованием операции побитового &laquo;или&raquo; (&laquo; | &raquo; ). Возможные режимы отображения  информации приведены в таблице.</p>
<p>Таблица  &ndash; режимы  отображения информации</p>
<div align="center">
  <table border="1" cellspacing="0" cellpadding="0" width="593">
    <tr>
      <td width="140"><br>
        <strong>GLUT_RGBA</strong></td>
      <td width="454"><p>Режим    RGBA. Используется по умолчанию, если не указаны явно режимы GLUT_RGBA или    GLUT_INDEX.</p></td>
    </tr>
    <tr>
      <td width="140"><p><strong>GLUT_RGB</strong></p></td>
      <td width="454"><p>То же, что    и GLUT_RGBA.</p></td>
    </tr>
    <tr>
      <td width="140"><p><strong>GLUT_INDEX</strong></p></td>
      <td width="454"><p>Режим    индексированных цветов (использование палитры). Отменяет GLUT_RGBA.</p></td>
    </tr>
    <tr>
      <td width="140"><p><strong>GLUT_SINGLE</strong></p></td>
      <td width="454"><p>Окно с    одиночным буфером. Используется по умолчанию.</p></td>
    </tr>
    <tr>
      <td width="140"><p><strong>GLUT_DOUBLE</strong></p></td>
      <td width="454"><p>Окно с    двойным буфером. Отменяет GLUT_SINGLE.</p></td>
    </tr>
    <tr>
      <td width="140"><p><strong>GLUT_STENCIL</strong></p></td>
      <td width="454"><p>Окно с    трафаретным буфером.</p></td>
    </tr>
    <tr>
      <td width="140"><p><strong>GLUT_ACCUM</strong></p></td>
      <td width="454"><p>Окно с    буфером накопления.</p></td>
    </tr>
    <tr>
      <td width="140" valign="top"><p><strong>GLUT_DEPTH</strong></p></td>
      <td width="454" valign="top"><p>Окно с    буфером глубины. </p></td>
    </tr>
  </table>
</div>
<p>В таблице  приведен  неполный список параметров для данной функции, однако, для большинства случаев  этого бывает достаточно.<br>
  Двойной буфер обычно  используют для анимации, сначала рисуя что-нибудь в одном буфере, а затем,  меняя их местами, что позволяет избежать мерцания. Буфер глубины или <em>z</em>-буфер используется для удаления  невидимых линий и поверхностей.<br>
  Функции библиотеки GLUT  реализуют так называемый событийно-управляемый механизм. Это означает, что есть  некоторый внутренний цикл, который запускается после соответствующей  инициализации и обрабатывает, один за другим, все события, объявленные во время  инициализации. К событиям относятся: щелчок мыши, закрытие окна, изменение  свойств окна, передвижение курсора, нажатие клавиши, и &laquo;пустое&raquo; (idle) событие,  когда ничего не происходит. Для проведения периодической проверки совершения  того или иного события надо зарегистрировать функцию, которая будет его  обрабатывать. Для этого используются функции вида:</p>
<p>void <strong>glutDisplayFunc</strong>(void (*func)(void))<br>
  void <strong>glutReshapeFunc</strong>(void  (*func)(int width, int height))<br>
  void <strong>glutMouseFunc</strong>(void  (*func)(int button, int state, int x, int y))<br>
  void <strong>glutIdleFunc</strong>(void  (*func)(void)) </p>
<p>То есть параметром для  них является имя соответствующей функции заданного типа. С помощью <em>glutDisplayFunc()</em> задается функция  рисования для окна приложения, которая вызывается при необходимости создания  или восстановления изображения. Для явного указания, что окно надо обновить,  иногда удобно использовать функцию</p>
<p>void <strong>glutPostRedisplay</strong>(void) </p>
<p>Через <em>glutReshapeFunc()</em> устанавливается  функция обработки изменения размеров окна пользователем, которой передаются  новые размеры.<br>
  <em>glutMouseFunc()</em> определяет обработчика  команд от мыши, а <em>glutIdleFunc()</em> задает функцию, которая будет вызываться каждый раз, когда нет событий от  пользователя.<br>
  Контроль всех событий  происходит внутри бесконечного цикла в функции</p>
<p>void <strong>glutMainLoop</strong>(void) </p>
<p>которая обычно вызывается  в конце любой программы, использующей GLUT.<br>
  Структура приложения, использующего  анимацию, будет следующей:</p>
<table border="0" cellpadding="0" width="92%">
  <tr>
    <td width="99%"><p>#include &lt;GL/glut.h&gt;<br>
      void MyIdle(void)<br>
      {<br>
      &nbsp;    /*Код, который меняет переменные,    определяющие следующий&nbsp; кадр */<br>
      &nbsp;    ...<br>
      }<br>
      void DrawGLScene(void) <br>
      {<br>
      &nbsp;    /* Код OpenGL, который отображает кадр */<br>
      &nbsp;    ...<br>
      &nbsp;    /* После рисования смена буфера */<br>
      &nbsp;    glutSwapBuffers();<br>
      }<br>
      void main(int argcp, char    **argv)<br>
      {<br>
      &nbsp; /* Инициализация GLUT */ <br>
      &nbsp; glutInit(&amp;argcp, argv);<br>
      &nbsp; glutInitWindowSize(640, 480);<br>
      &nbsp; glutInitWindowPosition(0, 0);<br>
      &nbsp; /* Открытие окна */ <br>
      &nbsp; glutCreateWindow(&quot;Приложение OpenGL&quot;);<br>
      &nbsp; /* Выбор режима:&nbsp; двойной буфер и RGBA цвета */ <br>
      &nbsp;    glutInitDisplayMode(GLUT_RGBA | GLUT_DOUBLE | GLUT_DEPTH);<br>
      &nbsp; /* Регистрация вызываемых функций */ <br>
      &nbsp;    glutDisplayFunc(DrawGLScene);<br>
      &nbsp;    glutIdleFunc(MyIdle);<br>
      &nbsp;    /* Запуск механизма обработки событий */<br>
      &nbsp;    glutMainLoop();<br>
      }</p></td>
  </tr>
</table>
<p>В случае если приложение  должно строить статичное изображение, можно заменить GLUT_DOUBLE на  GLUT_SINGLE, так как одного буфера в этом случае будет достаточно, и убрать  вызов функции <em>glutIdleFunc()</em>.</p>
<p>&nbsp;</p>
<h2><a name="_Toc307897361">2.3</a>&nbsp;Процесс обновления изображения<a name="E4CAC"></a></h2>
<p>&nbsp;</p>
<p>Как правило, задачей программы,  использующей OpenGL, является обработка трехмерной сцены и интерактивное  отображение в буфере кадра. Сцена состоит из набора трехмерных объектов,  источников света и виртуальной камеры, определяющей текущее положение  наблюдателя.<br>
  Обычно приложение OpenGL в  бесконечном цикле вызывает функцию обновления изображения в окне. В этой  функции и сосредоточены вызовы основных команд OpenGL. Если используется  библиотека GLUT, то это будет функция с обратным вызовом, зарегистрированная с  помощью вызова <em>glutDisplayFunc()</em>.  GLUT вызывает эту функцию, когда операционная система информирует приложение о  том, что содержимое окна необходимо перерисовать (например, если окно было  перекрыто другим). Создаваемое изображение может быть как статичным, так и анимированным,  т.е. зависеть от каких-либо параметров, изменяющихся со временем. В этом случае  лучше вызывать функцию обновления самостоятельно. Например, с помощью команды <em>glutPostRedisplay()</em>.<br>
  Как правило, функция обновления  изображения состоит из трех шагов:</p>
<ul>
  <li>очистка буферов OpenGL;</li>
  <li>установка положения наблюдателя;</li>
  <li>преобразование и рисование геометрических объектов.</li>
</ul>
<p>Очистка буферов производится с  помощью команды:</p>
<table border="0" cellpadding="0" width="75%">
  <tr>
    <td width="99%"><p>void <strong>glClearColor </strong>(clampf r, clampf g, clampf b, clampf a)<br>
      void <strong>glClear </strong>(bitfield buf)</p></td>
  </tr>
</table>
<p>Команда<strong>&nbsp;</strong><em>glClearColor</em> устанавливает цвет, которым будет  заполнен буфер кадра. Первые три параметра команды задают R,G и B компоненты  цвета и должны принадлежать отрезку [0,1]. Четвертый параметр задает так  называемую альфа компоненту. Как правило, он равен 1. По умолчанию цвет &ndash;  черный (0,0,0,1).<br>
  Команда <em>glClear</em> очищает буферы, а параметр&nbsp;<em>buf</em>&nbsp;определяет комбинацию констант, соответствующую  буферам, которые нужно очистить. Типичная программа вызывает команду</p>
<table border="0" cellpadding="0" width="73%">
  <tr>
    <td width="99%"><p><strong>glClear</strong>(GL_COLOR_BUFFER_BIT&nbsp;|&nbsp;GL_DEPTH_BUFFER_BIT) </p></td>
  </tr>
</table>
<p>для очистки буферов цвета и глубины.<br>
  Установка положения наблюдателя и  преобразования трехмерных объектов (поворот, сдвиг и т.д.) контролируются с  помощью задания матриц преобразования.<br>
  Сейчас сосредоточимся на том, как  передать в OpenGL описания объектов, находящихся в сцене. Каждый объект  является набором примитивов OpenGL.</p>
<p><a href="../../presentations/3-5 лекции Open GL.ppt" target="_new">Презентация к лекциям 3-5</a></p>
</body>
</html>
