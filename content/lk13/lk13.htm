<!-- (C) 2016 Хаджинова Н.В., каф. ИТАС, БГУИР -->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//RU">
<HTML>
<HEAD>
<LINK rel=stylesheet href="Оболочка/css/style.css" type=text/css>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=windows-1251">
<META HTTP-EQUIV="Content-Language" CONTENT="ru">
<title>Лекция № 13 &quot;Удаление невидимых линий и поверхностей&quot;</title>
</head>

<body>
<div align="center">
  <h1>Лекция № 13 &quot;<strong>Удаление невидимых линий и поверхностей</strong>&quot; </h1>
</div>
<hr>
<h2>Темы, рассматриваемые в данной лекции: </h2>
<ol>
  <li>Классификация алгоритмов удаления скрытых линий и поверхностей.</li>
  <li>Алгоритм плавающего горизонта.</li>
  <li>Алгоритм Робертса.</li>
  <li>Метод z-буфера.</li>
  <li>Метод трассировки лучей.</li>
  <li>Алгоритм Художника.</li>
  <li>Алгоритм Варнока.</li>
  <li>Алгоритм Вейлера-Азертона.</ol><hr>
    <h2><a name="_Toc195990541">1. Классификация алгоритмов удаления скрытых линий и поверхностей</a></h2>
    Алгоритмы удаления невидимых  линий и поверхностей служат для определения линий ребер, поверхностей или  объемов, которые видимы или невидимы для наблюдателя, находящегося в заданной  точке пространства.<br>
  Сложность задачи удаления  невидимых линий и поверхностей привела к появлению большого числа различных  способов ее решения. Многие из них ориентированы на специализированные  приложения. Наилучшего решения общей задачи удаления невидимых линий и  поверхностей не существует. Имеется тесная взаимосвязь между скоростью работы  алгоритма и детальностью его результата. Ни один из алгоритмов не может  достигнуть хороших оценок для этих двух показателей одновременно. Все алгоритмы  удаления невидимых линий или поверхностей включают в себя сортировку. Главная  сортировка проводится по геометрическому расстоянию от тела, поверхности, ребра  или точки до точки наблюдения. Основная идея, положенная в основу сортировки по  расстоянию, заключается в том, что чем дальше расположен объект от точки  наблюдения, тем больше вероятность, что он будет полностью или частично  заслонен одним из объектов, более близких к точке наблюдения. После определения  расстояний или приоритетов по глубине остается провести сортировку по  горизонтали и по вертикали, чтобы выяснить, будет ли рассматриваемый объект  действительно заслонен объектом, расположенным ближе к точке наблюдения.  Эффективность любого алгоритма удаления невидимых линий или поверхностей в  большой мере зависит от эффективности процесса сортировки.<br>
  Алгоритмы удаления невидимых  линий или поверхностей можно классифицировать по способу выбора системы  координат или пространства, в котором они работают. Алгоритмы, работающие в  объектном пространстве, имеют дело с физической системой координат, в которой  описаны эти объекты. При этом получаются весьма точные результаты, ограниченные  лишь точностью вычислений. Полученные изображения можно свободно увеличивать во  много раз. Алгоритмы, работающие в объектном пространстве, особенно полезны в  тех приложениях, где необходима высокая точность. Алгоритмы же, работающие в  пространстве изображения, имеют дело с системой координат того экрана, на  котором объекты визуализируются. При этом точность вычислений ограничена  разрешающей способностью экрана. Результаты, полученные в пространстве  изображения, а затем увеличенные во много раз, не будут соответствовать  исходной сцене.<br>
Объем вычислений для любого  алгоритма, работающего в объектном пространстве, и сравнивающий объект сцены со  всеми остальными объектами этой сцены, растет теоретически как квадрат числа  объектов (n2). Аналогично, объем вычислений любого алгоритма,  работающего в пространстве изображения и сравнивающего каждый объект сцены с  позициями всех пикселов в системе координат экрана, растет теоретически, как  nN, где n &ndash; количество объектов (тел, плоскостей, ребер и т.д.) в сцене, а N &ndash;  число пикселов. Теоретически большинство алгоритмов следует реализовывать в  объектном пространстве, так как обычно n &lt; N. Однако алгоритмы, работающие в  пространстве изображения, более эффективны потому что для них легче  воспользоваться преимуществом когерентности при растровой реализации.

<h2><a name="_Toc195990541">2. Алгоритм плавающего горизонта</a></h2>
<p>Алгоритм плавающего горизонта  чаще всего используется для удаления невидимых линий трехмерного представления  функций, описывающих поверхность в виде F(x, y, z) = 0.<br>
  Поскольку в приложениях в  основном интересуются описанием поверхности, этот алгоритм обычно работает в  пространстве изображений. Главная идея данного метода заключается в сведении  трехмерной задачи к двумерной путем пересечения исходной поверхности  последовательностью параллельных секущих плоскостей, имеющих постоянные  значения координат x, y или z.<br>
  На рис.37 приведен пример, где  указанные параллельные плоскости определяются постоянными значениями z. Функция  F(x, y, z) = 0 сводится к последовательности кривых, лежащих в каждой из этих  параллельных плоскостей, например к последовательности y=f(x,z) или x=g(y,z)  где z постоянно на каждой из заданных параллельных плоскостей.<br>
<img width="199" height="209" src="lk13_clip_image002.jpg" alt="LectSCGIm37"></p>
<p>Поверхность в этом случае  складывается из последовательности кривых, лежащих в каждой из этих плоскостей,  как показано на рис.38.<br>
  <img width="319" height="188" src="lk13_clip_image004.jpg" alt="LectSCGIm38"><br>
Если спроецировать полученные  кривые на плоскость z=0, как показано на рис.39, то идею алгоритма можно  описать следующим образом.</p>
<p align="center"><img width="251" height="112" src="lk13_clip_image006.jpg" alt="LectSCGIm39"></p>
<p>Алгоритм сначала упорядочивает  плоскости z=const по возрастанию расстояния до них от точки наблюдения. Затем  для каждой плоскости, начиная с ближайшей к точке наблюдения, строится кривая,  лежащая на ней, т.е. для каждого значения координаты x в пространстве  изображения определяется соответствующее значение y. Алгоритм удаления  невидимой линии заключается в следующем:<br>
  Если на текущей плоскости при  некотором заданном значении x соответствующее значение y на кривой больше  значения y для всех предыдущих кривых при этом значении x, то текущая кривая  видима в этой точке; в противном случае она невидима.<br>
  Невидимые участки показаны на  рис.39 пунктиром. Реализация данного алгоритма достаточна проста. Для хранения  максимальных значений y при каждом значении x используется массив, длина  которого равна числу различных точек (разрешению) по оси x в пространстве  изображения. Значения, хранящиеся в этом массиве, представляют собой текущие  значения &quot;горизонта&quot;. Фактически этот алгоритм удаления невидимых  линий работает каждый раз с одной линией.<br>
  Алгоритм работает хорошо до тех  пор, пока какая-нибудь очередная кривая не окажется ниже самой первой из  кривых, как показано на рис.40.</p>
<p align="center"><img width="280" height="146" src="lk13_clip_image008.jpg" alt="LectSCGIm40"></p>
<p>Подобные кривые, естественно,  видимы и представляют собой нижнюю сторону исходной поверхности, однако  алгоритм в существующем варианте будет считать их невидимыми. Нижняя сторона  поверхности становится видимой, если модифицировать этот алгоритм, включив в  него нижний горизонт, который опускается вниз по ходу работы алгоритма. Это  реализуется при помощи второго массива, длина которого равна числу различимых  точек по оси x в пространстве изображения. Этот массив содержит наименьшие  значения y для каждого значения x. Алгоритм преобразуется к следующему виду:<br>
  Если на текущей плоскости при  некотором заданном значении x соответствующее значение y на кривой больше  максимума или меньше минимума по y для всех предыдущих кривых при этом x, то  текущая кривая видима. В противном случае она невидима.<br>
  В изложенном алгоритме  предполагается, что значение функции, т.е. y, известно для каждого значения x в  пространстве изображения. Однако если для каждого значения x нельзя указать или  вычислить соответствующее ему значение y, то невозможно поддерживать массивы  верхнего и нижнего плавающих горизонтов. В таком случае используется линейная  интерполяция значений y между известными значениями для того, чтобы заполнить  массивы верхнего и нижнего плавающего горизонтов, как показано на рис.41.</p>
<p align="center"><img width="357" height="295" src="lk13_clip_image010.jpg" alt="LectSCGIm41"></p>
<p>Если видимость кривой меняется,  то метод с такой простой интерполяцией не даст корректного результата.  Предполагая, что операция по заполнению массивов проводится после проверки  видимости, становится очевидным, что при переходе текущей кривой от видимого к  невидимому состоянию (сегмент AB на рис.41), точка (xn+k, yn+k)  объявляется невидимой. Тогда участок кривой между точками (xn, yn)  и (xn+k, yn+k) не изображается и операция по заполнению  массивов не проводится. Образуется зазор между текущей и предыдущими кривыми.  Если на участке текущей кривой происходит переход от невидимого состояния к  видимому (сегмент CD на рис.41), то точка (xm+k, ym+k)  объявляется видимой, а участок кривой между точками (xm, ym)  и (xm+k, ym+k) изображается и операция по заполнению  массивов проводится. Поэтому изображается и невидимый кусок сегмента&nbsp; CD. Кроме того, массивы плавающих горизонтов  не будут содержать точных значений y. А это может повлечь нежелательные эффекты  для последующих кривых. Следовательно, необходимо решать задачу о поиске точек  пересечения сегментов текущей и предшествующих кривых.<br>
  Существует несколько методов  получения точек пересечения кривых. На растровых дисплеях значение координаты x  можно увеличивать на 1, начиная с xn или xm (рис.41).  Значение y, соответствующее текущему значению координаты x в пространстве  изображения, получается путем добавления к значению y, соответствующему  предыдущему значению координаты x, вертикального приращения &Delta;y вдоль заданной  кривой. Затем определяется видимость новой точки с координатами (x+1, y+&Delta;y).  Если эта точка видима, то активируется связанный с ней пиксел. Если невидима,  то пиксел не активируется, а x увеличивается на 1. Этот процесс продолжается до  тех пор, пока не встретится xn+k или xm+k. Пересечения  для растровых дисплеев определяются изложенным методом с достаточной точностью.<br>
  Точное значение точки пересечения  двух прямолинейных отрезков, которые интерполируют текущую и предшествующие  кривые, между точками (xn, yn) и (xn+k, yn+k)  (рис.41) задается формулами:<br>
  x = xn &ndash; (&Delta;x(ynp  &ndash; ync))/(&Delta;yp &ndash; &Delta;yc)<br>
  y = m(x &ndash; xn) + yn<br>
  где<br>
  &Delta;x = xn+k &ndash; xn<br>
  &Delta;yp = (yn+k)p &ndash;  (yn)p<br>
  &Delta;yc = (yn+k)c &ndash;  (yn)c<br>
  m = (yn+k &ndash; yn)/&Delta;x<br>
  а индексы c и p соответствуют текущей (current) и  предшествующей (previous) кривым. Полученный результат показан на рис.41.  Теперь алгоритм излагается более формально.</p>
<ul>
  <li>Если  на текущей плоскости при некотором заданном значении x соответствующее значение  y&nbsp; на кривой больше максимума или меньше  минимума по y для всех предыдущих кривых при этом x, то текущая кривая видима.  В противном случае она невидима.</li>
  <li>Если  на участке от предыдущего xn до текущего xn+k значения x  видимость кривой изменяется, то вычисляется точка пересечения xi.</li>
  <li>Если  на участке от xn до xn+k сегмент кривой полностью видим,  то он изображается целиком; если он стал невидимым, то изображается фрагмент от  xn до xi; если же он стал видимым, то изображается  фрагмент от xi до xn+k.</li>
  <li>Заполняются  массивы верхнего и нижнего плавающих горизонтов.</li>
</ul>
<p>Изложенный алгоритм приводит к  некоторым дефектам, когда кривая, лежащая в одной из более удаленных от точки  наблюдения плоскостей, появляется слева или справа из-под множества кривых,  лежащих в плоскостях, которые ближе к указанной точке наблюдения. Этот эффект  продемонстрирован на рис.42, где уже обработанные плоскости n-1 и n расположены  ближе к точке наблюдения.<br>
  <img width="241" height="160" src="lk13_clip_image012.jpg" alt="LectSCGIm42"><br>
  На рисунке показано, что  получается при обработке плоскости n+1. После обработки кривых n-1 и n верхний  горизонт для значений x=0 и 1 равен начальному значению y; для значений x от 2  до 14 равен ординатам кривой n; а для значений 15, 16, 17 &ndash; ординатам кривой  n-1. Нижний горизонт для значений x=0 и 1 равен начальному значению y; для  значений x=2, 3, 4 &ndash; ординатам кривой n; а для значений x от 5 до 17 &ndash;  ординатам кривой n-1. При обработке текущей кривой n+1 алгоритм объявляет ее  видимой при x=3. Это показано сплошной линией на рис.42. Аналогичный эффект  возникает и справа при x=15. Такой эффект приводит к появлению зазубренных  боковых ребер. Проблема с зазубренностью боковых ребер решается включением в  массивы верхнего и нижнего горизонтов ординат, соответствующих штриховым линиям  на рис.42. Это можно выполнить, создав ложные боковые ребра. Алгоритм,  реализующий эту идею для обоих ребер, имеет вид:<br>
  Обработка левого бокового ребра:</p>
<ul>
  <li>Если  Pn является первой точкой на первой кривой, то сохранить Pn  в качестве Pn-1 и закончить заполнение. В противном случае создается  ребро, соединяющее Pn и Pn-1.</li>
  <li>Занести  в массивы верхнего и нижнего горизонтов ординаты полученного ребра и сохранить  Pn в качестве Pn-1.</li>
</ul>
<p>Обработка правого бокового ребра:</p>
<ul>
  <li>Если  Pn является последней точкой на первой кривой, то сохранить Pn  в качестве Pn-1 и закончить заполнение. В противном случае создается  ребро, соединяющее Pn и Pn-1.</li>
  <li>Занести  в массивы верхнего и нижнего горизонтов ординаты полученного ребра и сохранить  Pn в качестве Pn-1.</li>
</ul>
<p>Теперь полный алгоритм плавающего  горизонта выглядит следующим образом:<br>
  Для каждой плоскости z=const:</p>
<ul>
  <li>Обработать  левое боковое ребро.</li>
  <li>Для  каждой точки, лежащей на кривой из текущей плоскости:</li>
  <li>Если  при некотором заданном значении x соответствующее значение y на кривой больше  максимума или меньше минимума по y для всех предыдущих кривых при этом x, то  кривая видима (в этой точке). В противном случае она невидима.</li>
  <li>Если  на сегменте от предыдущего xn до текущего xn+k значения x  видимость кривой изменяется, то вычисляется пересечение xi.</li>
  <li>Если  на участке от xn до xn+k сегмент кривой полностью видим,  то он изображается целиком; если он стал невидимым, то изображается его кусок  от xn до xi; если же он стал видимым, то изображается его  фрагмент от xi до xn+k.</li>
  <li>Заполнить  массивы верхнего и нижнего плавающих горизонтов.</li>
  <li>Обработать  правое боковое ребро.</li>
</ul>
<h2><a name="_Toc195990542">3. Алгоритм Робертса</a></h2>
<p>Алгоритм Робертса представляет  собой первое известное решение задачи об удалении невидимых линий. Это  математически элегантный метод, работающий в объектном пространстве. Алгоритм  прежде всего удаляет из каждого тела те ребра или грани, которые экранируются  самим телом. Затем каждое из видимых ребер каждого тела сравнивается с каждым  из оставшихся тел для определения того, какая его часть или части, если таковые  есть, экранируются этими телами. Поэтому вычислительная трудоемкость алгоритма  Робертса растет теоретически как квадрат числа объектов. Это в сочетании с  ростом популярности к растровым дисплеям, работающим в пространстве  изображения, привело к снижению интереса к алгоритму Робертса. Однако  математические методы, используемые в этом алгоритме, просты, мощны и точны.  Кроме того, более поздние реализации алгоритма, использующие предварительную  приоритетную сортировку вдоль оси z и простые габаритные или максимальные  тесты, демонстрируют почти линейную зависимость от числа объектов.<br>
  В алгоритме Робертса требуется,  чтобы все изображаемые тела или объекты были выпуклыми. Невыпуклые тела должны  быть разбиты на выпуклые части (см. раздел 6.3). В этом алгоритме выпуклое  многогранное тело с плоскими гранями должно представляться набором  пересекающихся плоскостей. Уравнение произвольной плоскости в трехмерном  пространстве имеет вид ax + by + cz + d = 0<br>
В матричной форме этот результат  выглядит так:</p>
<div align="center">
  <table border="0" cellspacing="0" cellpadding="0">
    <tr>
      <td valign="top"><p>&nbsp;</p></td>
      <td valign="top"><p>a</p></td>
      <td valign="top"><p>&nbsp;</p></td>
    </tr>
    <tr>
      <td valign="top"><p>[x y z 1]</p></td>
      <td valign="top"><p>b</p></td>
      <td valign="top"><p>= 0</p></td>
    </tr>
    <tr>
      <td valign="top"><p>&nbsp;</p></td>
      <td valign="top"><p>c</p></td>
      <td valign="top"><p>&nbsp;</p></td>
    </tr>
    <tr>
      <td valign="top"><p>&nbsp;</p></td>
      <td valign="top"><p>d</p></td>
      <td valign="top"><p>&nbsp;</p></td>
    </tr>
  </table>
</div>
<p>или<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [x  y z 1][P]T = 0<br>
  где [P]T = [a b c d] представляет собой  плоскость. Поэтому любое выпуклое тело можно выразить матрицей тела, состоящей  из коэффициентов уравнений плоскостей, т.е.</p>
<div align="center">
  <table border="0" cellspacing="0" cellpadding="0">
    <tr>
      <td valign="top"><p>&nbsp;</p></td>
      <td valign="top"><p>a1</p></td>
      <td valign="top"><p>a2</p></td>
      <td valign="top"><p>&hellip;</p></td>
      <td valign="top"><p>an</p></td>
    </tr>
    <tr>
      <td valign="top"><p>[V] =</p></td>
      <td valign="top"><p>b1</p></td>
      <td valign="top"><p>b2</p></td>
      <td valign="top"><p>&hellip;</p></td>
      <td valign="top"><p>bn</p></td>
    </tr>
    <tr>
      <td valign="top"><p>&nbsp;</p></td>
      <td valign="top"><p>c1</p></td>
      <td valign="top"><p>c2</p></td>
      <td valign="top"><p>&hellip;</p></td>
      <td valign="top"><p>cn</p></td>
    </tr>
    <tr>
      <td valign="top"><p>&nbsp;</p></td>
      <td valign="top"><p>d1</p></td>
      <td valign="top"><p>d2</p></td>
      <td valign="top"><p>&hellip;</p></td>
      <td valign="top"><p>dn</p></td>
    </tr>
  </table>
</div>
<p>где каждый столбец содержит коэффициенты одной плоскости.  Любая точка пространства представима в однородных координатах вектором [S] = [x  y z 1]. Если точка [S] лежит на плоскости, то [S]*[P] T = 0. Если же  [S] не лежит на плоскости, то знак этого скалярного произведения показывает, по  какую сторону от плоскости расположена точка. В алгоритме Робертса  предполагается, что точки, лежащие внутри тела, дают положительное скалярное  произведение.<br>
  Чтобы проиллюстрировать эти идеи  рассмотрим следующий пример.<br>
  Шесть плоскостей, описывающих  единичный куб с центром в начале координат, таковы: x1=1/2, x2=-1/2,  y3=1/2, y4=-1/2, z5=1/2, z6=-1/2.  Они изображены на рис.43.</p>
<p align="center"><img width="193" height="168" src="lk13_clip_image014.jpg" alt="LectSCGIm43"></p>
<p>Уравнение правой плоскости имеет  вид x1+0*y1+0*z1-1/2=0 или 2x1-1=0.  Полная матрица тела такова:</p>
<div align="center">
  <table border="0" cellspacing="0" cellpadding="0">
    <tr>
      <td valign="top"><p>&nbsp;</p></td>
      <td valign="top"><p>1</p></td>
      <td valign="top"><p>2</p></td>
      <td valign="top"><p>3</p></td>
      <td valign="top"><p>4</p></td>
      <td valign="top"><p>5</p></td>
      <td valign="top"><p>6</p></td>
      <td valign="top"><p>&nbsp;</p></td>
      <td valign="top"><p>1</p></td>
      <td valign="top"><p>2</p></td>
      <td valign="top"><p>3</p></td>
      <td valign="top"><p>4</p></td>
      <td valign="top"><p>5</p></td>
      <td valign="top"><p>6</p></td>
    </tr>
    <tr>
      <td valign="top"><p>&nbsp;</p></td>
      <td valign="top"><p>1</p></td>
      <td valign="top"><p>1</p></td>
      <td valign="top"><p>0</p></td>
      <td valign="top"><p>0</p></td>
      <td valign="top"><p>0</p></td>
      <td valign="top"><p>0</p></td>
      <td valign="top"><p>&nbsp;</p></td>
      <td valign="top"><p>2</p></td>
      <td valign="top"><p>2</p></td>
      <td valign="top"><p>0</p></td>
      <td valign="top"><p>0</p></td>
      <td valign="top"><p>0</p></td>
      <td valign="top"><p>0</p></td>
    </tr>
    <tr>
      <td valign="top"><p>[V]=</p></td>
      <td valign="top"><p>0</p></td>
      <td valign="top"><p>0</p></td>
      <td valign="top"><p>1</p></td>
      <td valign="top"><p>1</p></td>
      <td valign="top"><p>0</p></td>
      <td valign="top"><p>0</p></td>
      <td valign="top"><p>=</p></td>
      <td valign="top"><p>0</p></td>
      <td valign="top"><p>0</p></td>
      <td valign="top"><p>2</p></td>
      <td valign="top"><p>2</p></td>
      <td valign="top"><p>0</p></td>
      <td valign="top"><p>0</p></td>
    </tr>
    <tr>
      <td valign="top"><p>&nbsp;</p></td>
      <td valign="top"><p>0</p></td>
      <td valign="top"><p>0</p></td>
      <td valign="top"><p>0</p></td>
      <td valign="top"><p>0</p></td>
      <td valign="top"><p>1</p></td>
      <td valign="top"><p>1</p></td>
      <td valign="top"><p>&nbsp;</p></td>
      <td valign="top"><p>0</p></td>
      <td valign="top"><p>0</p></td>
      <td valign="top"><p>0</p></td>
      <td valign="top"><p>0</p></td>
      <td valign="top"><p>2</p></td>
      <td valign="top"><p>2</p></td>
    </tr>
    <tr>
      <td valign="top"><p>&nbsp;</p></td>
      <td valign="top"><p>-1/2</p></td>
      <td valign="top"><p>1/2</p></td>
      <td valign="top"><p>-1/2</p></td>
      <td valign="top"><p>1/2</p></td>
      <td valign="top"><p>-1/2</p></td>
      <td valign="top"><p>1/2</p></td>
      <td valign="top"><p>&nbsp;</p></td>
      <td valign="top"><p>-1</p></td>
      <td valign="top"><p>1</p></td>
      <td valign="top"><p>-1</p></td>
      <td valign="top"><p>1</p></td>
      <td valign="top"><p>-1</p></td>
      <td valign="top"><p>1</p></td>
    </tr>
  </table>
</div>
<p>Эту матрицу тела следует  проверить с помощью одной из тех точек, о которых известно, что они лежат  внутри тела, чтобы убедиться, что знаки каждого уравнения плоскости выбраны  верно. Если знак скалярного произведения для какой-нибудь плоскости меньше  нуля, то соответствующее уравнение плоскости следует умножить на -1. Точка  внутри куба с координатами x=1/4, y=1/4, z=1/4 представляется в однородных  координатах в виде вектора [S]=[1/4 1/4 1/4 1] = [1 1 1 4]. Скалярное  произведение этого вектора на матрицу объема равно: </p>
<div align="center">
  <table border="0" cellspacing="0" cellpadding="0">
    <tr>
      <td valign="top"><br clear="all">
        <p>&nbsp;</p></td>
      <td valign="top"><p>1</p></td>
      <td valign="top"><p>2</p></td>
      <td valign="top"><p>3</p></td>
      <td valign="top"><p>4</p></td>
      <td valign="top"><p>5</p></td>
      <td valign="top"><p>6</p></td>
      <td valign="top"><p>&nbsp;</p></td>
    </tr>
    <tr>
      <td valign="top"><p>&nbsp;</p></td>
      <td valign="top"><p>2</p></td>
      <td valign="top"><p>2</p></td>
      <td valign="top"><p>0</p></td>
      <td valign="top"><p>0</p></td>
      <td valign="top"><p>0</p></td>
      <td valign="top"><p>0</p></td>
      <td valign="top"><p>&nbsp;</p></td>
    </tr>
    <tr>
      <td valign="top"><p>[S]*[V] = [1 1 1 4]</p></td>
      <td valign="top"><p>0</p></td>
      <td valign="top"><p>0</p></td>
      <td valign="top"><p>2</p></td>
      <td valign="top"><p>2</p></td>
      <td valign="top"><p>0</p></td>
      <td valign="top"><p>0</p></td>
      <td valign="top"><p>= [-2 6 -2 6 -2 6]</p></td>
    </tr>
    <tr>
      <td valign="top"><p>&nbsp;</p></td>
      <td valign="top"><p>0</p></td>
      <td valign="top"><p>0</p></td>
      <td valign="top"><p>0</p></td>
      <td valign="top"><p>0</p></td>
      <td valign="top"><p>2</p></td>
      <td valign="top"><p>2</p></td>
      <td valign="top"><p>&nbsp;</p></td>
    </tr>
    <tr>
      <td valign="top"><p>&nbsp;</p></td>
      <td valign="top"><p>-1</p></td>
      <td valign="top"><p>1</p></td>
      <td valign="top"><p>-1</p></td>
      <td valign="top"><p>1</p></td>
      <td valign="top"><p>-1</p></td>
      <td valign="top"><p>1</p></td>
      <td valign="top"><p>&nbsp;</p></td>
    </tr>
  </table>
</div>
<p>Здесь результаты для первого,  третьего и пятого уравнений плоскостей (столбцов) отрицательны, и,  следовательно, они составлены некорректно. Умножая эти уравнения (столбцы) на  -1, получаем корректную матрицу тела для данного куба:</p>
<div align="center">
  <table border="0" cellspacing="0" cellpadding="0">
    <tr>
      <td valign="top"><p>&nbsp;</p></td>
      <td valign="top"><p>1</p></td>
      <td valign="top"><p>2</p></td>
      <td valign="top"><p>3</p></td>
      <td valign="top"><p>4</p></td>
      <td valign="top"><p>5</p></td>
      <td valign="top"><p>6</p></td>
    </tr>
    <tr>
      <td valign="top"><p>&nbsp;</p></td>
      <td valign="top"><p>-2</p></td>
      <td valign="top"><p>2</p></td>
      <td valign="top"><p>0</p></td>
      <td valign="top"><p>0</p></td>
      <td valign="top"><p>0</p></td>
      <td valign="top"><p>0</p></td>
    </tr>
    <tr>
      <td valign="top"><p>[V] =</p></td>
      <td valign="top"><p>0</p></td>
      <td valign="top"><p>0</p></td>
      <td valign="top"><p>-2</p></td>
      <td valign="top"><p>2</p></td>
      <td valign="top"><p>0</p></td>
      <td valign="top"><p>0</p></td>
    </tr>
    <tr>
      <td valign="top"><p>&nbsp;</p></td>
      <td valign="top"><p>0</p></td>
      <td valign="top"><p>0</p></td>
      <td valign="top"><p>0</p></td>
      <td valign="top"><p>0</p></td>
      <td valign="top"><p>-2</p></td>
      <td valign="top"><p>2</p></td>
    </tr>
    <tr>
      <td valign="top"><p>&nbsp;</p></td>
      <td valign="top"><p>1</p></td>
      <td valign="top"><p>1</p></td>
      <td valign="top"><p>1</p></td>
      <td valign="top"><p>1</p></td>
      <td valign="top"><p>1</p></td>
      <td valign="top"><p>1</p></td>
    </tr>
  </table>
</div>
<p>В приведенном примере  корректность уравнений плоскостей была проверена экспериментально. Разумеется,  это не всегда возможно. Существует несколько полезных методов для общего  случая.<br>
  Хотя уравнение плоскости ax + by  + cz + d = 0 содержит четыре неизвестных коэффициента, его можно нормировать  так, чтобы d=1. Следовательно, трех неколлинеарных точек достаточно для  определения этих коэффициентов. Подстановка координат трех неколлинеарных точек  (x1, y1, z1), (x2, y2, z2),  (x3, y3, z3) в нормированное уравнение ax + by  + cz + d = 0 дает:</p>
<p align="center">ax1 + by1 + cz1  = -1<br>
  ax2 + by2 + cz2  = -1<br>
  ax3 + by3  + cz3 = -1</p>
<p>В матричной форме последняя  система выглядит следующим образом:</p>
<div align="center">
  <table border="0" cellspacing="0" cellpadding="0">
    <tr>
      <td valign="top"><p>x1</p></td>
      <td valign="top"><p>y1</p></td>
      <td valign="top"><p>z1</p></td>
      <td valign="top"><p>&nbsp;</p></td>
      <td valign="top"><p>a</p></td>
      <td valign="top"><p>&nbsp;</p></td>
      <td valign="top"><p>-1</p></td>
    </tr>
    <tr>
      <td valign="top"><p>x2</p></td>
      <td valign="top"><p>y2</p></td>
      <td valign="top"><p>z2</p></td>
      <td valign="top"><p>&nbsp;</p></td>
      <td valign="top"><p>b</p></td>
      <td valign="top"><p>=</p></td>
      <td valign="top"><p>-1</p></td>
    </tr>
    <tr>
      <td valign="top"><p>x3</p></td>
      <td valign="top"><p>y3</p></td>
      <td valign="top"><p>z3</p></td>
      <td valign="top"><p>&nbsp;</p></td>
      <td valign="top"><p>c</p></td>
      <td valign="top"><p>&nbsp;</p></td>
      <td valign="top"><p>-1</p></td>
    </tr>
  </table>
</div>
<p>или [X][C]=[D].<br>
  Решение этого уравнения дает  значения коэффициентов уравнения плоскости:<br>
  [C]=  [X]-1[D].<br>
  Другой способ используется, если  известен вектор нормали к плоскости, т.е. n=ai+bj+ck, где i, j, k &ndash; единичные  векторы осей x, y, z соответственно. Тогда уравнение плоскости примет вид  ax+by+cz+d=0. Величина d вычисляется с помощью произвольной точки на плоскости.  В частности, если компоненты этой точки на плоскости (x1, y1,  z1), то: d = -(ax1 + by1 + cz1).<br>
  Поскольку объем вычислений в  алгоритмах удаления невидимых линий или поверхностей растет с увеличением числа  многоугольников, для описания поверхностей выгодно использовать многоугольники  с более чем тремя сторонами. Эти многоугольники могут быть как невыпуклыми, так  и неплоскими. Метод, предложенный Мартином Ньюэлом, позволяет найти как точное  решение для уравнения плоскостей, содержащих плоские многоугольники, так и  &quot;наилучшее&quot; приближение для неплоских многоугольников. Этот метод  эквивалентен определению нормали в каждой вершине многоугольника посредством  векторного произведения прилежащих ребер и уравнения результатов. Если a, b, c,  d &ndash; коэффициенты уравнения плоскости, то<br>
  a= Sumi=1-n((yi  &ndash; yj) (zi + zj))<br>
  b= Sumi=1-n((zi &ndash; zj)  (xi + xj))<br>
  c= Sumi=1-n((xi &ndash; xj)  (yi + yj))<br>
  где j = (i == n)? 1: i+1, а d вычисляется с помощью любой  точки на плоскости. Этот метод иллюстрируется следующим примером.<br>
  Рассмотрим четырехсторонний  плоский многоугольник, описываемый четырьмя вершинами V1(1, 0, 0), V2(0,  1, 0), V3(0, 0, 1), V4(1, -1, 1) (см. рис.44).<br>
  <img width="157" height="176" src="lk13_clip_image016.jpg" alt="LectSCGIm44"></p>
<p>Подставляя вершины V1,  V2, V3 в уравнение [X][C]=[D], получаем:</p>
<table border="1" cellspacing="0" cellpadding="0">
  <tr>
    <td valign="top"><p>1</p></td>
    <td valign="top"><p>0</p></td>
    <td valign="top"><p>0</p></td>
    <td valign="top"><p>&nbsp;</p></td>
    <td valign="top"><p>a</p></td>
    <td valign="top"><p>&nbsp;</p></td>
    <td valign="top"><p>-1</p></td>
  </tr>
  <tr>
    <td valign="top"><p>0</p></td>
    <td valign="top"><p>1</p></td>
    <td valign="top"><p>0</p></td>
    <td valign="top"><p>&nbsp;</p></td>
    <td valign="top"><p>b</p></td>
    <td valign="top"><p>=</p></td>
    <td valign="top"><p>-1</p></td>
  </tr>
  <tr>
    <td valign="top"><p>0</p></td>
    <td valign="top"><p>0</p></td>
    <td valign="top"><p>1</p></td>
    <td valign="top"><p>&nbsp;</p></td>
    <td valign="top"><p>c</p></td>
    <td valign="top"><p>&nbsp;</p></td>
    <td valign="top"><p>-1</p></td>
  </tr>
</table>
<p>или, решая относительно коэффициентов уравнения плоскости:</p>
<div align="center">
  <table border="0" cellspacing="0" cellpadding="0">
    <tr>
      <td valign="top"><p>a</p></td>
      <td valign="top"><p>&nbsp;</p></td>
      <td valign="top"><p>1</p></td>
      <td valign="top"><p>0</p></td>
      <td valign="top"><p>0</p></td>
      <td valign="top"><p>&nbsp;</p></td>
      <td valign="top"><p>-1</p></td>
      <td valign="top"><p>&nbsp;</p></td>
      <td valign="top"><p>-1</p></td>
    </tr>
    <tr>
      <td valign="top"><p>b</p></td>
      <td valign="top"><p>=</p></td>
      <td valign="top"><p>0</p></td>
      <td valign="top"><p>1</p></td>
      <td valign="top"><p>0</p></td>
      <td valign="top"><p>&nbsp;</p></td>
      <td valign="top"><p>-1</p></td>
      <td valign="top"><p>=</p></td>
      <td valign="top"><p>-1</p></td>
    </tr>
    <tr>
      <td valign="top"><p>c</p></td>
      <td valign="top"><p>&nbsp;</p></td>
      <td valign="top"><p>0</p></td>
      <td valign="top"><p>0</p></td>
      <td valign="top"><p>1</p></td>
      <td valign="top"><p>&nbsp;</p></td>
      <td valign="top"><p>-1</p></td>
      <td valign="top"><p>&nbsp;</p></td>
      <td valign="top"><p>-1</p></td>
    </tr>
  </table>
</div>
<p>Полученное в результате уравнение  плоскости имеет вид -x-y-z+1=0 или x+y+z-1=0.<br>
  Решая другим методом, получаем  нормаль к этой плоскости, используя векторное произведение пары векторов,  являющихся смежными ребрами одной из вершин. Векторное произведение двух  пространственных векторов V1 и V2 вычисляется по формуле</p>
<div align="center">
  <table border="0" cellspacing="0" cellpadding="0">
    <tr>
      <td rowspan="2" valign="top"><p>V1#V2=</p></td>
      <td valign="top"><p>&nbsp;</p></td>
      <td valign="top"><p>V1y</p></td>
      <td valign="top"><p>V1z</p></td>
      <td valign="top"><p>, -</p></td>
      <td valign="top"><p>V1x</p></td>
      <td valign="top"><p>V1z</p></td>
      <td valign="top"><p>,</p></td>
      <td valign="top"><p>V1x</p></td>
      <td valign="top"><p>V1y</p></td>
      <td valign="top"><p>&nbsp;</p></td>
    </tr>
    <tr>
      <td valign="top"><p>&nbsp;</p></td>
      <td valign="top"><p>V2y</p></td>
      <td valign="top"><p>V2z</p></td>
      <td valign="top"><p>&nbsp;</p></td>
      <td valign="top"><p>V2x</p></td>
      <td valign="top"><p>V2z</p></td>
      <td valign="top"><p>&nbsp;</p></td>
      <td valign="top"><p>V2x</p></td>
      <td valign="top"><p>V2y</p></td>
      <td valign="top"><p>&nbsp;</p></td>
    </tr>
  </table>
</div>
<p>Ребра смежные вершине V2 образуют вектора V2V3  и V2V1 с координатами, соответственно (0, -1, 1) и (1,  -1, 0), таким образом нормаль к исследуемой плоскости будет равна:</p>
<div align="center">
  <table border="0" cellspacing="0" cellpadding="0">
    <tr>
      <td rowspan="2" valign="top"><p>n = V2V3#V2V1    =</p></td>
      <td valign="top"><p>&nbsp;</p></td>
      <td valign="top"><p>-1</p></td>
      <td valign="top"><p>1</p></td>
      <td valign="top"><p>, -</p></td>
      <td valign="top"><p>0</p></td>
      <td valign="top"><p>1</p></td>
      <td valign="top"><p>,</p></td>
      <td valign="top"><p>0</p></td>
      <td valign="top"><p>-1</p></td>
      <td valign="top"><p>&nbsp;</p></td>
      <td valign="top"><p>= (1, 1, 1)</p></td>
    </tr>
    <tr>
      <td valign="top"><p>&nbsp;</p></td>
      <td valign="top"><p>-1</p></td>
      <td valign="top"><p>0</p></td>
      <td valign="top"><p>&nbsp;</p></td>
      <td valign="top"><p>1</p></td>
      <td valign="top"><p>0</p></td>
      <td valign="top"><p>&nbsp;</p></td>
      <td valign="top"><p>1</p></td>
      <td valign="top"><p>-1</p></td>
      <td valign="top"><p>&nbsp;</p></td>
      <td valign="top"><p>&nbsp;</p></td>
    </tr>
  </table>
</div>
<p>Используя уравнение: d = -(ax1 + by1 +  cz1) и вершину V4 вычисляется значение постоянного члена  в уравнении плоскости: d = -(1-1+1) = -1. Следовательно, уравнение плоскости  опять имеет вид x+y+z-1=0.<br>
  Если обратиться к методу Ньюэла  при n=4, то будут иметь место следующие уравнения:<br>
  a = (V1y &ndash; V2y)(V1z + V2z)+(V2y  &ndash; V3y)(V2z + V3z)+(V3y &ndash; V4y)(V3z  + V4z)+(V4y &ndash; V1y)(V4z + V1z)<br>
  b = (V1z &ndash; V2z)(V1x + V2x)+(V2z  &ndash; V3z)(V2x + V3x)+(V3z &ndash; V4z)(V3x  + V4x)+(V4z &ndash; V1z)(V4x + V1x)<br>
  c = (V1x &ndash; V2x)(V1y + V2y)+(V2x  &ndash; V3x)(V2y + V3y)+(V3x &ndash; V4x)(V3y  + V4y)+(V4x &ndash; V1x)(V4y + V1y)<br>
  Решая данные уравнения, получаем  a = 2, b = 2, c = 2.<br>
  Используя вершину V4 для  вычисления постоянного члена: d = -(2-2+2) = -2. После деления на 2 уравнение  плоскости опять принимает вид x+y+z-1=0.<br>
  Перед началом работы алгоритма  удаления невидимых линий или поверхностей для получения желаемого вида сцены  часто применяется трехмерное видовое преобразование. Матрицы тел для объектов  преобразованной сцены можно получить или преобразованием исходных матриц тел  или вычислением новых матриц тел, используя преобразованные вершины или точки.<br>
  Если [B] &ndash; матрица однородных  координат, представляющая исходные вершины тела, а [T] &ndash; матрица размером 4х4  видового преобразования, то преобразованные вершины таковы:<br>
  [BT] = [B][T],<br>
  где [BT] &ndash; преобразованная матрица вершин.<br>
  Использование уравнения  [X][C]=[D] позволяет получить уравнения исходных плоскостей, ограничивающих  тело:<br>
  [B][V] = [D],<br>
  где [V] &ndash; матрица тела, а [D] в правой части &ndash; нулевая  матрица. Аналогично уравнения преобразованных плоскостей задаются следующим  образом:<br>
  [BT][VT] = [D],<br>
  где [VT] &ndash; преобразованная матрица тела. Приравнивая левые  части последних уравнений получаем:<br>
  [BT][VT] = [B][V]<br>
  Подставляя уравнение [BT] =  [B][T], сокращая на [B] и умножая слева на [T]-1, имеем<br>
  [VT] = [T]-1[V]<br>
  Таким образом, преобразованная  матрица тела получается умножением исходной матрицы тела слева на обратную  матрицу видового преобразования.<br>
  Рассмотрим перенос единичного  куба с центром в начале координат на три единицы в положительном направлении  оси x. Соответствующая матрица преобразования размером 4х4 имеет вид</p>
<div align="center">
  <table border="0" cellspacing="0" cellpadding="0">
    <tr>
      <td valign="top"><p>&nbsp;</p></td>
      <td valign="top"><p>1</p></td>
      <td valign="top"><p>0</p></td>
      <td valign="top"><p>0</p></td>
      <td valign="top"><p>0</p></td>
    </tr>
    <tr>
      <td valign="top"><p>[T]=</p></td>
      <td valign="top"><p>0</p></td>
      <td valign="top"><p>1</p></td>
      <td valign="top"><p>0</p></td>
      <td valign="top"><p>0</p></td>
    </tr>
    <tr>
      <td valign="top"><p>&nbsp;</p></td>
      <td valign="top"><p>0</p></td>
      <td valign="top"><p>0</p></td>
      <td valign="top"><p>1</p></td>
      <td valign="top"><p>0</p></td>
    </tr>
    <tr>
      <td valign="top"><p>&nbsp;</p></td>
      <td valign="top"><p>3</p></td>
      <td valign="top"><p>0</p></td>
      <td valign="top"><p>0</p></td>
      <td valign="top"><p>1</p></td>
    </tr>
  </table>
</div>
<p>А обратная к ней матрица такова</p>
<div align="center">
  <table border="0" cellspacing="0" cellpadding="0">
    <tr>
      <td valign="top"><p>&nbsp;</p></td>
      <td valign="top"><p>1</p></td>
      <td valign="top"><p>0</p></td>
      <td valign="top"><p>0</p></td>
      <td valign="top"><p>0</p></td>
    </tr>
    <tr>
      <td valign="top"><p>[T]-1= </p></td>
      <td valign="top"><p>0</p></td>
      <td valign="top"><p>1</p></td>
      <td valign="top"><p>0</p></td>
      <td valign="top"><p>0</p></td>
    </tr>
    <tr>
      <td valign="top"><p>&nbsp;</p></td>
      <td valign="top"><p>0</p></td>
      <td valign="top"><p>0</p></td>
      <td valign="top"><p>1</p></td>
      <td valign="top"><p>0</p></td>
    </tr>
    <tr>
      <td valign="top"><p>&nbsp;</p></td>
      <td valign="top"><p>-3</p></td>
      <td valign="top"><p>0</p></td>
      <td valign="top"><p>0</p></td>
      <td valign="top"><p>1</p></td>
    </tr>
  </table>
</div>
<p>Умножение матрицы тела данного  единичного куба на [T]-1 дает матрицу тела для перенесенного куба:</p>
<div align="center">
  <table border="0" cellspacing="0" cellpadding="0">
    <tr>
      <td valign="top"><p>&nbsp;</p></td>
      <td valign="top"><p>1</p></td>
      <td valign="top"><p>0</p></td>
      <td valign="top"><p>0</p></td>
      <td valign="top"><p>0</p></td>
      <td valign="top"><p>&nbsp;</p></td>
      <td valign="top"><p>-2</p></td>
      <td valign="top"><p>2</p></td>
      <td valign="top"><p>0</p></td>
      <td valign="top"><p>0</p></td>
      <td valign="top"><p>0</p></td>
      <td valign="top"><p>0</p></td>
      <td valign="top"><p>&nbsp;</p></td>
      <td valign="top"><p>-2</p></td>
      <td valign="top"><p>2</p></td>
      <td valign="top"><p>0</p></td>
      <td valign="top"><p>0</p></td>
      <td valign="top"><p>0</p></td>
      <td valign="top"><p>0</p></td>
    </tr>
    <tr>
      <td valign="top"><p>[VT]=[T]-1[V]=</p></td>
      <td valign="top"><p>0</p></td>
      <td valign="top"><p>1</p></td>
      <td valign="top"><p>0</p></td>
      <td valign="top"><p>0</p></td>
      <td valign="top"><p>&nbsp;</p></td>
      <td valign="top"><p>0</p></td>
      <td valign="top"><p>0</p></td>
      <td valign="top"><p>-2</p></td>
      <td valign="top"><p>2</p></td>
      <td valign="top"><p>0</p></td>
      <td valign="top"><p>0</p></td>
      <td valign="top"><p>=</p></td>
      <td valign="top"><p>0</p></td>
      <td valign="top"><p>0</p></td>
      <td valign="top"><p>-2</p></td>
      <td valign="top"><p>2</p></td>
      <td valign="top"><p>0</p></td>
      <td valign="top"><p>0</p></td>
    </tr>
    <tr>
      <td valign="top"><p>&nbsp;</p></td>
      <td valign="top"><p>0</p></td>
      <td valign="top"><p>0</p></td>
      <td valign="top"><p>1</p></td>
      <td valign="top"><p>0</p></td>
      <td valign="top"><p>&nbsp;</p></td>
      <td valign="top"><p>0</p></td>
      <td valign="top"><p>0</p></td>
      <td valign="top"><p>0</p></td>
      <td valign="top"><p>0</p></td>
      <td valign="top"><p>-2</p></td>
      <td valign="top"><p>2</p></td>
      <td valign="top"><p>&nbsp;</p></td>
      <td valign="top"><p>0</p></td>
      <td valign="top"><p>0</p></td>
      <td valign="top"><p>0</p></td>
      <td valign="top"><p>0</p></td>
      <td valign="top"><p>-2</p></td>
      <td valign="top"><p>2</p></td>
    </tr>
    <tr>
      <td valign="top"><p>&nbsp;</p></td>
      <td valign="top"><p>-3</p></td>
      <td valign="top"><p>0</p></td>
      <td valign="top"><p>0</p></td>
      <td valign="top"><p>1</p></td>
      <td valign="top"><p>&nbsp;</p></td>
      <td valign="top"><p>1</p></td>
      <td valign="top"><p>1</p></td>
      <td valign="top"><p>1</p></td>
      <td valign="top"><p>1</p></td>
      <td valign="top"><p>1</p></td>
      <td valign="top"><p>1</p></td>
      <td valign="top"><p>&nbsp;</p></td>
      <td valign="top"><p>7</p></td>
      <td valign="top"><p>-5</p></td>
      <td valign="top"><p>1</p></td>
      <td valign="top"><p>1</p></td>
      <td valign="top"><p>1</p></td>
      <td valign="top"><p>1</p></td>
    </tr>
  </table>
</div>
<p>Первый столбец в преобразованной  матрице тела содержит коэффициенты уравнения плоскости правой грани:<br>
  -2x+7=0 или x=3.5<br>
  аналогично из второго столбца получаем уравнение для  плоскости левой грани:<br>
  2x-5=0 или x=2.5,<br>
  что полностью соответствует ожиданиям.<br>
  В примере с кубом точка [S]=[1/4  1/4 1/4 1] = [1 1 1 4] лежала внутри непреобразованного тела. Следовательно,  [S]*[V]&gt;=0. Однако точка [S] лежит вне перенесенного тела. Проверка  скалярного произведения точки [S] и матрицы преобразованного тела обнаруживает  один отрицательный элемент во втором столбце, который соответствует левой грани  куба.<br>
  [S]*[VT] = [1 1 1 4]*[VT] = [26  -18 2 6 2 6]<br>
  Это является следствием того, что  точка расположена с внешней стороны относительно левой грани.<br>
  Если зритель находится в  бесконечности на положительной полуоси z и смотрит на начало координат, то его  взгляд направлен в сторону отрицательной полуоси z. в однородных координатах  вектор такого направления равен [E] = [0 0 -1 0], который служит еще и образом  точки лежащей в бесконечности на отрицательной полуоси z, т.е. любой точки типа  (x, y, -&infin;).<br>
  Поэтому, если скалярное  произведение [E] на столбец, соответствующий какой-нибудь плоскости в матрице  тела, отрицательно, то [E] лежит по отрицательную сторону этой плоскости.  Следовательно, такие плоскости невидимы из любой точки наблюдения, лежащей в  плоскости z = +&infin;. Описываемые плоскости называются нелицевыми. Следовательно  [E]*[V]&lt;0 является условием того, что плоскости &ndash; нелицевые.<br>
  Вновь рассмотрим единичный куб с  центром в начале координат. Точка наблюдения находится на положительной полуоси  z, ее координаты [0 0 1 0], взгляд направлен на начало координат. Скалярное  произведение указанного вектора на матрицу тела дает:<br>
  [E]*[V] = [0 0 -1 0]*[V] = [0 0 0  0 2 -2]<br>
  Отрицательное число в шестом  столбце показывает, что грань с этим номером нелицевая. Нулевые результаты  соответствуют плоскостям, параллельным направлению взгляда.<br>
  После определения нелицевых  плоскостей необходимо найти нелицевые отрезки, которые образуются в результате  пересечения нелицевых плоскостей. Затем необходимо выяснить, существуют ли  такие отрезки, которые экранируются другими телами в сцене.<br>
  Для сравнения отрезка P1P2  с телом удобно использовать параметрическое представление этого отрезка:<br>
  P(t) = P1 + (P2 &ndash;  P1)t,&nbsp;&nbsp; 0 &le; t &le; 1, или v  = s + dt, где<br>
  v &ndash; вектор точки на отрезке, s &ndash; начальная точка, а d &ndash;  направление отрезка. Если отрезок невидим, то надо найти те значения t, для  которых он невидим. Для этого формируется другой параметрический отрезок от  точки P(t) до точки наблюдения g:<br>
  Q(&alpha;, t) = u = v + g&alpha; = s + dt +  g&alpha;,&nbsp;&nbsp;&nbsp;&nbsp; 0 &le; t &le; 1, &alpha; &ge; 0.<br>
  Так как скалярное произведение  любой точки, лежащей внутри тела, на матрицу тела положительно, то для  определения части отрезка, которая экранируется телом, достаточно найти те  значения &alpha; и t, для которых скалярное произведение Q(&alpha;, t) = u на матрицу тела  положительно. Это скалярное произведение равно<br>
  h = u*[VT] = s*[VT] + dt*[VT] +  g&alpha;*[VT] &gt; 0,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0 &le; t &le; 1, &alpha; &ge; 0.<br>
  Если все компоненты h  неотрицательны для некоторых t и &alpha;, то отрезок при этих значениях t  экранируется данным телом. Обозначив<br>
  p = s*[VT]<br>
  q = d*[VT]<br>
  w = g*[VT]<br>
  можно записать условия в виде<br>
  hj = pj + qjt  + wj&alpha; &gt; 0,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0 &le; t &le; 1,  &alpha; &ge; 0,<br>
  где&nbsp; j &ndash; номер столбца  в матрице тела. Эти условия должны выполняться при всех значениях j, т.е. для  всех плоскостей, ограничивающих объем тела. Пограничный случай между видимостью  и невидимостью возникает, когда hj = 0. При hj = 0 точка  лежит на плоскости. Полагая hj = 0 для всех плоскостей, получаем  систему уравнений относительно t и &alpha;, которые должны удовлетворяться  одновременно. Результат можно получить путем совместного решения всевозможных  пар уравнений из этой системы, при этом будут найдены все значения t и &alpha;, при  которых изменяется значение видимости отрезка. Число возможных решений при j  уравнениях (плоскостях) равно j(j-1)/2. Каждое решение в диапазонах 0 &le; t &le; 1,  &alpha; &ge; 0 подставляется во все остальные уравнения для проверки того, что условие hj  &ge; 0 выполнено. Среди максимальных значений параметра t осуществляется поиск  минимального значения tminmax и максимального значения tmaxmin  среди минимальных. Отрезок невидим при tmaxmin &lt; t &lt; tminmax.<br>
  Ниже приводится эффективная  реализация алгоритма Робертса. Этот алгоритм делится на три этапа. На первом  этапе каждое тело анализируется индивидуально с целью удаления нелицевых  плоскостей. На втором этапе проверяется экранирование оставшихся в каждом теле  ребер всеми другими телами с целью обнаружения их невидимых отрезков. На  третьем этапе вычисляются отрезки, которые образуют новые ребра при  пронизывании телами друг друга. В данном алгоритме предполагается, что тела  состоят из плоских полигональных граней, которые в свою очередь состоят из  ребер, а ребра &ndash; из отдельных вершин.<br>
  Удаление невидимых плоскостей.<br>
  Для каждого тела в сцене:</p>
<ul>
  <li>Сформировать  многоугольники граней и ребра, исходя из списка вершин тела.</li>
  <li>Вычислить  уравнение плоскости для каждой полигональной грани тела.</li>
  <li>Проверить  знак уравнения плоскости:</li>
  <li>Взять  любую точку внутри тела, например, усреднив координаты его вершин.</li>
  <li>Вычислить  скалярное произведение уравнения плоскости и точки внутри тела.</li>
  <li>Если  это скалярное произведение меньше нуля, то изменить знак уравнения этой  плоскости.</li>
  <li>Сформировать  матрицу тела.</li>
  <li>Умножить  ее слева на матрицу, обратную матрице видового преобразования, включающего  перспективу.</li>
  <li>Вычислить  и сохранить габариты прямоугольной объемлющей оболочки преобразованного объема:  xmax, xmin, ymax, ymin.</li>
  <li>Определить  нелицевые плоскости:</li>
  <li>Вычислить  скалярное произведение пробной точки, лежащей в бесконечности, на  преобразованную матрицу тела.</li>
  <li>Если  это скалярное произведение меньше нуля, то плоскость невидима.</li>
  <li>Удалить  весь многоугольник, лежащий в этой плоскости.</li>
  <li>Удалить  из каждого тела те ребра, которые экранируются всеми остальными телами в сцене:</li>
  <li>Если  задано только одно тело, то алгоритм завершается.</li>
  <li>Сформировать  приоритетный список этих тел.</li>
</ul>
<p>Провести сортировку по z.  Сортировка производится по максимальным значениям координаты z вершин  преобразованных тел. Первым в упорядоченном списке и обладающим наибольшим  приоритетом будет то тело, у которого минимальное среди максимальных значений  z. В используемой правой системе координат это тело будет самым удаленным от  точки наблюдения, расположенной в бесконечности на оси z.</p>
<ul>
  <li>Для  каждого тела из приоритетного списка:</li>
</ul>
<p>Проверить экранирование всех  лицевых ребер всеми другими телами сцены. Тело, ребра которого проверяются,  называется пробным объектом, а тело, относительно которого в настоящий момент  производится проверка, называется пробным телом. Естественно нужно проверять  экранирование пробного объекта только теми пробными телами, у которых ниже  приоритеты.</p>
<ul>
  <li>Провести  проверки экранирования для прямоугольных объемлющих оболочек пробного объекта и  пробного тела:</li>
</ul>
<p>Если <br>
  xmin(пробное тело)  &gt; xmax(пробный объект) или<br>
  xmax(пробное тело)  &lt; xmin(пробный объект) или<br>
  ymin(пробное тело)  &gt; ymax(пробный объект) или<br>
  ymax(пробное тело)  &lt; ymin(пробный объект),<br>
  то пробное тело не может экранировать  ни одного ребра пробного объекта. Перейти к следующему пробному телу. В  противном случае:</p>
<ul>
  <li>Провести  предварительные проверки пронизывания, чтобы определить, не протыкается ли  пробное тело пробным объектом и существует ли возможность частичного экранирования  первого последним.</li>
</ul>
<p>Сравнить максимальное значение z  у пробного объекта с минимальным значением z&nbsp;  у пробного тела.<br>
  Если zmax(пробный  объект) &lt; zmin(пробное тело), то пронизывание невозможно. Перейти  к следующему телу. В противном случае:<br>
  Проверить видимое пронизывание:<br>
  Если zmax(пробный  объект) &lt; zmin(пробное тело), то пробный объект может пройти  через переднюю грань пробного тела.<br>
  Установить флаг видимого  пронизывания для последующего использования. Занести пронизанное тело в список  пронизываний.<br>
  Если <br>
  xmin(пробное тело)  &lt; xmax(пробный объект) или<br>
  xmax(пробное тело)  &gt; xmin(пробный объект),<br>
  то пробный объект может пронизать  бок пробного тела.<br>
  Установить флаг видимого  пронизывания для последующего использования. Занести тело в список пронизываний.<br>
  Если <br>
  ymin(пробное тело)  &lt; ymax(пробный объект) или<br>
  ymax(пробное тело)  &gt; ymin(пробный объект),<br>
  то пробный объект может пронизать  верх или низ пробного тела.<br>
  Установить флаг видимого  пронизывания для последующего использования. Занести тело в список пронизываний.</p>
<ul>
  <li>Произвести  проверки экранирования ребер:</li>
</ul>
<p>Вычислить s и d для ребра.<br>
  Вычислить p, q, w для каждой  плоскости, несущей грань пробного тела.<br>
  Проверка полной видимости. Если  ребро полностью видимо, то перейти к следующему ребру. Сформировать уравнения hj=0  и решить их, объединяя попарно и включив в систему уравнения границ t=0 и t=1.  Если установлен флаг видимого пронизывания, то в систему надо включить и  уравнение границы &alpha;=0. Сохранить точки пронизывания. В противном случае границу  &alpha;=0 не учитывать.<br>
  Для каждой пары (t, &alpha;),  являющейся решением, проверить выполнение условий 0&le;t&le;1, &alpha;&ge;0 и hj&gt;0  для всех других плоскостей. Если эти условия выполняются, то вычислить tmaxmin  и tminmax.<br>
  Вычислить видимые участки  отрезков и сохранить их для последующей проверки экранирования телами с более  низкими приоритетами.</p>
<ul>
  <li>Определить  видимые отрезки, связывающие точки пронизывания:</li>
  <li>Если  флаг видимого пронизывания не установлен, перейти к процедуре визуализации.</li>
  <li>Если  точек пронизывания не обнаружено, перейти к процедуре визуализации.</li>
</ul>
<p>Сформировать все возможные ребра,  соединяющие точки пронизывания, для пар тел, связанных отношением пронизывания.<br>
  Проверить экранирование всех  соединяющих ребер обоими телами, связанными отношением пронизывания.<br>
  Проверить экранирование  оставшихся соединяющих ребер всеми прочими телами сцены. Сохранить видимые  отрезки.</p>
<ul>
  <li>Визуализировать  оставшиеся видимые отрезки ребер.</li>
</ul>
<p><strong>Дополнительно изучить</strong> материал на <a href="../../extra_books/Компьютерная графика_С.М. Брундасов.pdf">стр. 172-208 Учебного пособия С.М. Брундасова &quot;Компьютерная графика&quot;</a></p>
</body>
</html>
